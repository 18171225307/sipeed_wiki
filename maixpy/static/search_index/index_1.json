{"/maixpy/doc/zh/basic/os.html":{"title":"升级和烧录系统","content":" title: 升级和烧录系统 ## 介绍 如果你购买了官方（Sipeed）的带 TF 卡的套餐，一般来说出厂已经烧录好了系统，可以跳过这一步直接使用。 但是为了防止出厂烧录的系统版本过旧，强烈建议先按照教程升级到最新的系统。 ## 如何确认系统是否需要升级 * 在开机后的功能选择界面，点击`设置`，然后点击`设备信息`，可以看到系统的版本号。 * 到[MaixPy 发布历史页面](https://github.com/sipeed/MaixPy/releases)查看更新日志，里面有 MaixPy 固件和系统镜像的更新说明，如果在你的版本后有重要更新，建议升级。 > 如果最新系统和当前系统对比只是 MaixPy 固件的常规更新，也可以不升级，在 `设置` 中的 `更新 MaixPy` 中单独更新 `MaixPy` 即可。 ## 获得最新系统 在 [MaixPy 发布页面](https://github.com/sipeed/MaixPy/releases) 找到最新的系统镜像文件，比如`maixcam_os_20240401_maixpy_v4.1.0.xz`。 备用地址： * [Sourceforge](https://sourceforge.net/projects/maixpy/files/) ## 烧录系统到 MaixCAM 参考 [MaixCAM 系统烧录](https://wiki.sipeed.com/hardware/zh/maixcam/os.html) 教程。"},"/maixpy/doc/zh/basic/python_pkgs.html":{"title":"添加额外的 Python 软件包","content":" title: 添加额外的 Python 软件包 ## 简介 MaixPy 基于 Python 语言，提供了大量方便嵌入式应用开发的功能和 API，除此之外，你也可以使用其它的 Python 包来扩展功能。 ## 安装额外的 Python 包 > 注意可能不是所有 Python 包都支持，一般只支持纯 Python 包，不支持 C 扩展包， C 扩展包可能需要你手动在电脑交叉编译（比较复杂，这里就不介绍了）。 ### 方法一： 使用 Python 代码来安装 在 MaixVision 中使用 Python 代码来安装你需要的包，比如： ```python import os os.system(\"pip install 包名\") ``` 要更新一个包，可以使用： ```python import os os.system(\"pip install upgrade 包名\") ``` ### 方法二： 终端使用 pip 命令安装 使用[Linux 基础](./linux_basic.html)中介绍的终端使用方法，使用 `pip install 包名` 安装你需要的包。"},"/maixpy/doc/zh/basic/app_usage.html":{"title":"应用使用说明","content":" title: 应用使用说明 开机后会自动进入应用选择界面，内置各种应用均发布在 [MaixHub 应用商店](https://maixhub.com/app)， 可以在这里找到对应应用的介绍和使用说明。 上手用得比较多的是 `设置 > 语言`， 以及 `设置 > WiFi`，`应用商店`应用可以用来升级和安装应用，连接上可以连接互联网的 WiFi 后即可在[MaixHub 应用商店](https://maixhub.com/app)扫码安装应用。 另外，你编写的应用也可以上传到[MaixHub 应用商店](https://maixhub.com/app)分享给其他人使用，质量合格和优秀的应用都会得到官方红包打赏，优秀应用也会得到大家的赞同和支持。 无论是小到一个采集传感器的数据小应用还是功能复杂的应用，让我们一起来创造更多有趣的东西吧！"},"/maixpy/doc/zh/basic/maixpy_upgrade.html":{"title":"更新 MaixPy","content":" title: 更新 MaixPy 有两种方法，如果第一次上手使用，为了降低难度，可以直接使用出厂 TF 卡自带的 MaixPy 固件尝试，以后再考虑更新。 不过因为不知道你拿到手的是什么时候出厂的 TF 卡，所以建议都更新一下系统。 ## 直接更新系统 按照 [升级和烧录系统](./os.html) 中的操作升级到最新的系统，里面就包含了最新的 MaixPy 固件。 ## 只更新 MaixPy 固件 在 [MaixPy 仓库 release 页面](https://github.com/sipeed/MaixPy/releases) 看到最新的版本信息和更新日志，其中包含了 MaixPy 固件信息，以及对应版本使用的系统信息。 如果不想更新系统（因为一般系统变动不大，可以看 MaixPy 更新日志中是否有系统改动相关，再决定是否更新系统），则可以只更新 MaixPy 固件。 * 在设置中设置 WiFi， 让系统联网。 * 点击设置应用中的 `更新 MaixPy` 进行更新。 > 如果你会使用终端， 也可以在终端中使用 `pip install MaixPy U` 来更新 MaixPy。"},"/maixpy/doc/zh/pro/compile_os.html":{"title":"","content":""},"/maixpy/doc/zh/vision/ai.html":{"title":"AI 视觉基本知识","content":" title: AI 视觉基本知识 update: date: 2024 04 03 author: neucrack version: 1.0.0 content: 初版文档 ## 简介 如果没有 AI 基础，在学习 AI 前可以先看[什么是人工智能(AI)和机器学习](https://wiki.sipeed.com/ai/zh/basic/what_is_ai.html) 了解一下 AI 的基本概念。 然后我们使用的视觉 AI 一般都是基于`深度神经网络学习`这个方法，有兴趣可以看看[深度神经网络（DNN）基础知识](https://wiki.sipeed.com/ai/zh/basic/dnn_basic.html) ## MaixPy 中使用视觉 AI 在 MaixPy 中使用视觉 AI 很简单，默认提供了常用的 AI 模型，不需要自己训练模型就可以直接使用，在[MaixHub 模型库](https://maixhub.com/model/zoo) 中选择`maixcam` 就可以找到。 并且在底层已经封装好的 API，只需要简单的调用就可以实现。 如果你想训练自己的模型，也可以先从[MaixHub 在线训练](https://maixhub.com/model/training/project) 开始，在线平台只需要点点点就能训练出模型，不需要购买昂贵的机器，不需要搭建复杂的开发环境，也不需要写代码，非常适合入门，也适合懒得翻代码的老手。 一般训练得到了模型文件，直接传输到设备上，调用 MaixPy 的 API 就可以使用了，具体的调用方法看后文。"},"/maixpy/doc/zh/vision/self_learn_detector.html":{"title":"MaixPy 自学习检测器","content":" title: MaixPy 自学习检测器 ## MaixPy 自学习检测器 和自学习分类器类似，不需要训练，直接拍摄几张要检测的物体照片即可实现检测，在简单检测场景下十分好用。 和自学习分类器不同的是因为是检测器，会有物体的坐标和大小。 ## MaixPy 中使用自学习检测器 TODO："},"/maixpy/doc/zh/faq.html":{"title":"MaixPy FAQ(常见问题)","content":" title: MaixPy FAQ(常见问题) 此页面列出了 MaixPy 相关的常见问题和解决方案，如果你遇到了问题，请先在这里找寻答案。 如果这个页面找不到答案，可以到 [MaixHub 讨论版块](https://maixhub.com/discussion) 将问题的详细步骤发贴提问。 如果你使用的是 MaixCAM, 也可以参考 [MaixCAM FAQ](https://wiki.sipeed.com/hardware/zh/maixcam/faq.html) ## MaixVision 无法搜索到设备？ 先确认连接方式是 WiFi 还是 USB 线， **WiFi**: * 确认 WiFi 是否正确连接上并且获取到 IP 地址， 可以在 `设置 >设备信息` 或者`设置 >WiFi` 里面看到 `ip`。 **USB线**: * 确保设备通过 Type C 数据线连接到电脑，设备处于开机状态并且进入了功能选择界面。 * 确保设备驱动已经安装： * Windows 下可以在`设备管理器`中查看是否有 USB 虚拟网卡设备，如果有感叹号则是去动没有安装好，按照[快速开始](./index.html) 中的方法安装驱动即可。 * Linux 下可以通过`ifconfig`或者`ip addr`查看是否有`usb0`设备或者`lsusb`查看所有 USB 设备。 Linux 已经自带去动，所以识别不到检查硬件连接，设备系统是否是最新，以及设备是否已经正常启动即可。 * Mac OS 同 Linux 方法。 * 另外 检查 USB 线缆的质量，换一个高质量的线缆。 * 另外 检查电脑 USB 口的质量，比如实测某些小主机 USB 口 EMI 设计太糟糕，外接一个质量好点的 USB HUB 反而可以使用了，也可以换 USB 口 或者直接换台电脑。 ## MaixVision 运行摄像头例程显示图像卡顿 默认配的 GC4653 摄像头最高帧率为 30 帧，摄像头例程正常情况下 MaixVision 的显示肉眼不会有卡顿感，如果卡顿，首先考虑传输问题： * 检查网络连接质量，比如 WiFi。 * 如果用的 USB 连接，检查 USB 线质量， 电脑 USB 口质量，可以尝试换台电脑或者 USB 口 或者 USB 线缆尝试对比。 ## MaixPy v4 和 v1 v3 有什么区别？ * MaixPy v4 使用 Python 语言，是吸取了 v1 v3 经验的集大成之作，有更好的配套软件和生态，更多的功能，更简单的使用方式和更完善的文档；硬件有很大提升的同时加个和另外两者的硬件价格想当甚至更便宜；另外也做了兼容 K210 的使用体验和 API，方便用户从 v1 快速迁移到 v4。 * v1 使用了 Micropython 语言，有很多局限性，比如第三方库支持有限；同时受限于 Maix I (K210) 的硬件性能，内存不够用，AI 模型支持有限，很多编解码不支持硬件加速等缺点。 * v3 也是使用了 Python 语言，基于 Maix II Dock (v831) 硬件，硬件 AI 模型支持有限，而且全志的基础生态不够开放，API 也不够完善，此版本仅作为 Maix II Dock (v831)上面使用，不会继续更新。 ## MaixPy 目前只支持 MaixCAM 吗，用其它同款芯片的板子行不行？ MaixPy 目前仅支持 MaixCAM 系列板子，其它同款芯片的板子也不支持（包括 Sipeed 的同款芯片板子 比如 LicheeRV Nano），强烈不建议尝试，导致设备损坏（比如冒烟烧屏等）后果自负。 未来 Sipeed 出的 Maix 系列的产品都将继续得到 MaixPy 支持，目前如果 MaixCAM 有什么无法满足的需求，可以到 [MaixHub 讨论版块](https://maixhub.com/discussion) 提出需求或者发送邮件到 support@sipeed.com. ## 可以用除了官方搭配的摄像头或者屏幕以外的自己的摄像头或者屏幕吗？ 不建议这样操作，除非你有够丰富的软硬件知识和经验，否则可能导致设备损坏。 官方搭配的配件对应的软硬件是调教过的，表现效果是最好的，上手即可使用，其它配件可能接口不同，驱动不同，软件不同，需要自己去调教，这是一个非常复杂的过程，不建议尝试。 当然，如果你是大佬，我们也欢迎你提交 PR！ ## 运行模型报错 cvimodel built for xxxcv181x CANNOT run on platform cv181x 解析模型文件失败了，一般情况是模型文件损坏造成的，确保你的模型文件是没有损坏的。 比如： * 如果是从网上下载的，保证下载没有出问题，一般网上的文件提供 sha256sum/md5 校验值，下载下来后可以对比一下，具体方法请自行搜索或者问 ChatGPT。 * 如果是来自压缩包，请确认解压过程没有出错，可以从压缩包重新解压一遍保证中间没有出错。 * 保证传输到设备的过程没有造成文件损坏，可以对比一下设备中的文件和电脑中的文件 sha256sum 值，具体方法请自性搜索或者问 ChatGPT。 ## 上电启动黑屏，屏幕无显示 * 检查是否安装了 TF（micro SD）卡。 * 检查 TF 卡里面是否烧录了最新的系统镜像（强烈推荐烧录到最新的系统镜像），具体烧录方法看文档。 * 检查 TF 卡是否完全插进到了 TF 卡口，确保没有缝隙和松动。 * 检查屏幕和摄像头排线是否正确扣紧了，不能出现松动现象。 * 检查板子上的电源灯（红灯）以及系统运行状态灯（蓝灯）是否亮起，如果红灯不亮则考虑硬件问题，比如无供电或者供电不足或者板子烧坏了。 * 用 USB 转 TTL 连接电脑和板子的串口，电脑打开串口助手，让板子重启，查看启动日志里面是否有报错。 > 如果没有日志输出，可以尝试交换一下 TX 和 RX 接线， 对于 MaixCAM, Type C 转 串口小板插的方向不一样 TX RX 可能反向，即不支持正反插。"},"/maixpy/doc/zh/basic/python.html":{"title":"Python 基础知识","content":" title: Python 基础知识 MaixPy 的教程文档里面就不涉及具体的 Python 语法教程了，因为 Python 的教程实在是太多了，都做得很好，这里只介绍需要学什么，方向和线路指导即可。 ## Python 简介 Python 是一门解释性、面向对象、动态类型的高级编程语言。 * 解释性：不需要编译，直接运行，优点是开发快速，缺点是因为每次运行都要解释一遍代码，运行速度慢一点点，但是往往瓶颈还是开发者写的代码而不是语言本身。 * 面向对象：支持面向对象编程，可以定义类和对象，相比面向过程语言，更容易组织代码。更多自行搜索。 * 动态类型：变量不需要声明类型，可以直接赋值，类型会根据赋值自动确定，这样可以减少代码量，但是也容易出现类型错误，需要开发者自己注意。 总之，对于没有接触过 Python 的开发者来说，Python 非常容易上手，有大量现成的库，开发者群体巨大，开发应用周期短，非常值得学习！ ## Python 环境安装 你可以按照你学习的 Python 教程在电脑上安装 Python； 也可以在 MaixVisioin 上连接设备后使用 MaixVision 编程然后在开发板运行。 ## 使用 MaixPy 需要的 Python 基础有哪些？ * Python 的基本概念。 * 面向对象编程的基本概念。 * Python 的基本语法，包括： * tab 缩进对齐语法 * 变量、函数、类、对象、注释等 * 控制语句比如 if、for、while 等等 * 模块和导入模块 * 基本数据类型比如 int、float、str、list、dict、tuple 等等 * bytes 和 str 的区别和转换 * 异常处理，try except * 常用的内置函数，比如 print、open、len、range 等等 * 常用的内置模块，比如 os、sys、time、random、math 等等 掌握以上的基础知识就可以顺畅使用 MaixPy 编程了，配合后面的教程和例程，在不懂的时候查询搜索引擎或者官方文档，或者问 ChatGPT 就能顺利完成开发。 ## 对于已经有一门面向对象编程语言经验的开发者 如果你已经会一门面向对象语言比如 C++/Java/C# 等等，那只需要快速浏览一下 Python 的语法，就可以开始使用了。 比如 [菜鸟教程](https://www.runoob.com/python3/python3 tutorial.html) 或者 [Python 官方教程](https://docs.python.org/3/tutorial/index.html)。 或者个人开发者的博客，比如 [哇！是 Python](https://neucrack.com/p/59)。 ## 对于没有面向对象编程经验但是有 C 语言经验的开发者 如果只学了 C，缺乏对面向对象的理解，那么可以先学习一下面向对象的概念，然后再学习 Python，也是比较快的，可以自行搜索视频教程入门。 跟着视频教程入门之后可以看看文档教程，比如 [菜鸟教程](https://www.runoob.com/python3/python3 tutorial.html) 或者 [Python 官方教程](https://docs.python.org/3/tutorial/index.html) 就可以开动了！ 在学了入门知识后，就可以按照 MaixPy 的文档和例程开始使用 MaixPy 编程了。 ## 对于编程新手 如果你从未接触过编程，那么你需要重头开始学习 Python，Python 作为入门语言也是比较合适的，具体可以搜一搜视频教程。 在学会了基础语法后，就能按照例程使用 MaixPy 编程了。"},"/maixpy/doc/zh/basic/linux_basic.html":{"title":"Linux 基础知识","content":" title: Linux 基础知识 ## 简介 本章内容对于刚入门的同学来说，可以先跳过此章节，在学会 MaixPy 基础开发后再来学习也是可以的。 最新的 MaixPy 支持的 MaixCAM 硬件支持跑 Linux 系统，所以 MaixPy 底层都是基于 Linux 系统进行开发的。 虽然 Sipeed 开发的 MaixPy 已经为开发者们做了很多工作，即使不知道 Linux 系统知识也能愉快使用，但是以防在某些情况下需要一些底层操作，以及方便未接触过 Linux 的开发者学习，这里写一些 Linux 基础知识。 ## 为什么需要 Linux 系统 具体的原因大家可以自行查阅，这里用通俗的看起来不太专业的话语简单举几个例子方便初学者理解： * 在单片机中，我们的程序是一个死循环程序，用上 Linux 后我们可以同时跑很多程序，每个程序看起来都独立在同时运行，每个程序具体怎么执行的由操作系统实现。 * 基于 Linux 的开发者众多，需要功能和驱动可以很方便地找到，不需要自己再实现一遍。 * 基于 Linux 配套的软件工具丰富，可以很方便地进行开发和调试，比如在本教程没有提到的一些 Linux 通用工具理论上也是可以使用的。 ## 文件系统 什么是文件系统？ * 就像电脑的文件系统一样，Linux 上会将硬件磁盘用文件系统进行管理，这样我们可以很方便地向磁盘读写数据。 * 对于学过单片机没有接触过文件系统开发的同学来讲，可以理解为我们有一个 Flash 或者 TF 卡，我们可以通过 API 读写 Flash 存取数据，断电后也能保存数据，但是 Flash 具有读写寿命，我们往往需要写一套程序去保证 Flash 读写寿命，而文件系统就可以理解成这样一套成熟的程序，文件系统帮我们完成了具体如何管理 Flash 空间和读写，我们只需调用文件系统的 API 即可，大大减少了我们的开发工作量并且用成熟的程序保证了稳定性和安全性。 ## 在电脑和设备（开发板）之间传输文件 既然设备有 Linux 和文件系统，那我们怎么发送文件到设备呢？ 对于 MaixPy 我们配套了 MaixVision， 在后面的版本也会支持文件管理功能，在此之前可以用下面的方法： 这里我们主要介绍通过网络传输的方式，其它方式可自行探索`传输文件到 Linux`： * 确保设备和电脑连接到了同一个局域网，比如： * MaixCAM 的 USB 口连接到电脑会创建一个虚拟网卡，在电脑端的设备管理器就能看到，设备的 IP 可以在设备的`设置 >设备信息`中看到设备名和 IP。 * 也可以在设备`设置 >WiFi`中连接到和电脑相同的局域网。 * 电脑使用 SCP 或者 SFTP 协议传输文件到设备，具体的软件有很多，具体的软件和使用方法可以自行搜索，比如： * 在 Windows 上可以使用 WinSCP 或者 FileZilla，或者 scp 命令等。 * 在 Linux 上可以使用 FileZilla 或者 scp 命令 等。 * 在 Mac 上可以使用 FileZilla 或者 scp 命令 等。 ## 终端和命令行 终端就是通过`终端`这个软件与 Linux 系统进行通信和操作的工具，类似于 Windows 的`cmd`或者`PowerShell`。 比如我们可以在电脑的 Window 系统中的 powershell 或者 Linux系统中的 终端 工具中输入`ssh root@maixcam xxxx.local` 这里具体的名字在设备的`设置 >设备信息`中可以看到，这样我们就可以通过终端连接到设备了(用户名和密码都是`root`)。 然后我们通过输入命令来操作设备，比如`ls`命令可以列出设备文件系统中当前目录下的文件, `cd` 用来切换当前所在的目录（就像电脑文件管理中点击文件夹切换目录一样）， ```shell cd / # 切换到根目录 ls # 显示当前目录（根目录）下的所有文件 ``` 然后会显示类似下面的内容： ```shell bin lib media root tmp boot lib64 mnt run usr dev linuxrc opt sbin var etc lost+found proc sys ``` 更多命令学习请自行搜索`Linux 命令行使用教程`，这里只是为了让初学者知道基本概念，这样有开发者提到时可以知道是什么意思。"},"/maixpy/doc/zh/basic/maixvision.html":{"title":"MaixVision -- MaixPy 编程 + 图形化积木编程","content":" title: MaixVision MaixPy 编程 + 图形化积木编程 ## 简介 MaixVision 是专为 Maix 生态打造的一款开发者编程工具，支持 MaixPy 编程和图形化积木编程，同时支持在线运行和调试，以及实时预览图像，可以同步设备显示屏的图像，方便调试和开发。 以及支持打包应用和安装应用到设备，方便用户一键生成、安装应用。 同时还集成一些方便开发的小工具，比如文件管理，阈值编辑器，二维码生成等等。 ## 使用 MaixPy 编程和在线运行 按照[快速开始](../index.html)的步骤连接设备，我们可以很方便地使用 MaixPy 编程和在线运行。 ## 实时预览图像 MaixPy 提供`display`模块，可以将图像显示到屏幕上，同时，在调用`display`模块的`show`方法时，会将图像发送到 MaixVision 显示，比如代码： ```python from maix import display, camera cam camera.Camera(640, 480) disp display.Display() while 1: disp.show(cam.read()) ``` 这里我们用摄像头读取了图像，然后通过`disp.show()`方法将图像显示到屏幕上，同时也会发送到 MaixVision 显示。 当我们点击了右上角的`暂停`按钮，就会停止发送图像到 MaixVision 显示。 ## 计算图像的直方图 在上一步中我们可以在 MaixVision 中实时看到图像，我们用鼠标框选一个区域，图像下方就能看到这个区域的直方图了，选择不同的颜色表示方法，可以看到不同的颜色通道的直方图。 这个功能方便我们在做某些图像处理算法时找到一些合适的参数。 ## 使用图形化积木编程 开发中，敬请期待。 ## 区分`设备文件系统`和`电脑文件系统` 这里我们有一个比较重要的概念需要掌握：**分清楚`设备文件系统`和`电脑文件系统`**。 * **电脑文件系统**：运行在电脑上，在 MaixVision 中打开文件或者工程都是打开的电脑里面的文件，保存也是自动保存到电脑的文件系统。 * **设备文件系统**：程序运行时会将程序发送到设备上运行，所以代码里面使用的文件都是从设备文件系统读取。 所以常见的问题是有同学在电脑上保存了文件`D:\\data\\a.jpg`，然后在设备上使用这个文件`img image.load(\"D:\\data\\a.jpg\")`，这样当然是找不到文件的，因为设备上没有`D:\\data\\a.jpg`这个文件。 具体如何将电脑的文件发送到设备上，参考下面的章节。 ## 传输文件到设备 开发中，敬请期待。 目前可以用其它工具代替： 先知道设备的 ip 地址或者设备名称，MaixVision 就可以搜索到, 或者在设备`设置 >系统信息`中看到，比如类似 `maixcam xxxx.local` 或者 `192.168.0.123`。 用户名和密码都是 `root`, 使用 `SFTP` 协议传输文件，端口号是 `22`。 然后不同系统下都有很多好用的软件： ### Windows 下 使用 [WinSCP](https://winscp.net/eng/index.php) 或者 [FileZilla](https://filezilla project.org/) 等工具连接设备，将文件传输到设备上，选择 `SFTP` 协议填写设备和账号信息连接即可。 具体不懂的可以自行搜索。 ### Linux 下 终端使用 `scp` 命令传输文件到设备上，比如： ```bash scp /path/to/your/file.py root@maixcam xxxx.local:/root ``` ### Mac 下 * **方法一**：终端使用 `scp` 命令传输文件到设备上，比如： ```bash scp /path/to/your/file.py root@maixcam xxxx.local:/root ``` * **方法二**：使用 [FileZilla](https://filezilla project.org/) 等工具连接设备，将文件传输到设备上，选择 `SFTP` 协议填写设备和账号信息连接即可。"},"/maixpy/doc/zh/basic/app.html":{"title":"应用开发和应用商店","content":" title: 应用开发和应用商店 ## 应用生态简介 为了让开发板做到开箱即用，以及方便用户无门槛地使用，以及方便开发者分享自己的有趣应用，并且能有有效的渠道获取到反馈甚至是收益，我们推出了一个简易的应用框架，包括： * **[应用商店](https://maixhub.com/app)**： 开发者上传分享应用，用户无需开发直接下载使用，开发者可以获取到一定的现金收益（来自 MaixHub 官方以及用户打赏）。 * **出厂内置大量应用**： 官方提供了一些常用的应用，比如找色块、AI 物体检测追踪、找二维码、人脸识别等等，用户可以直接使用，也可以作为串口模块直接使用。 * **MaixPy + MaixCDK** 软件开发包：使用 [MaixPy](https://github.com/sipeed/maixpy) 或者 [MaixCDK](https://github.com/sipeed/MaixCDK) 可以用 Python 或者 C/C++ 语言快速开发嵌入式 AI 视觉听觉应用，超高效率实现你的有趣想法。 * **MaixVision** 配套电脑端开发工具: 全新的电脑端代码开发工具，快速上手、调试、运行、上传代码、安装应用到设备，一键式开发，甚至支持图像化积木式编程，小学生也能轻松上手。 大家可以多多关注应用商店，也可以在应用商店中分享自己的应用，大家一起共建活跃的社区。 ## 打包应用 使用 MaixPy + MaixVison 可以方便地开发、打包、安装应用： * 在 MaixVision 中使用 MaixPy 开发应用程序，可以是单个文件，也可以是一个工程目录。 * 连接设备。 * 点点击 MaixVision 左下角的 安装 按钮，会弹出一个界面填写应用的基本信息，id 是用来判别应用的 id，一个设备不能同时安装相同 id 的不同应用，所以 id 应该与 MaixHub 上面已经有的应用 id 不同，应用名字可以重复。以及图标等。 * 点击打包应用，会将应用打包成一个安装包，如果你要上传到 [MaixHub 应用商店](https://maixhub./com/app)，用这个打包好的文件即可。 * 点击 安装应用，这会将打包好的应用安装到设备。 * 断开与设备的连接，就能看到设备功能选择界面多了一个你的应用，直接点进去就能运行。 > 如果你用 MaixCDK 开发，使用 `maixcdk relrease` 就能打包出来一个应用，具体看 MaixCDK 的文档。 ## 退出应用 如果你只是写了比较简单的应用，没有做界面和返回按钮，默认可以按设备上的功能按键（一般是 USER 或者 FUNC 或者 OK 按钮）或者返回按钮（如果有这个按键，MaixCAM 默认没有这个按键）来退出应用。 ## 应用开发基本准则 * 因为默认都配了触摸屏幕，推荐都写一个简单的界面显示，最好有触摸交互。实现方法可以在例子里面找找参考。 * 界面和按钮不要太小，因为 MaixCAM 默认的屏幕是 2.3寸 552x368分辨率，PPI 比较高屏幕比较小，要让手指能很容易戳到并且不会点错。 * 每个应用实现的主要功能实现一个简单的串口交互，基于[串口协议](https://github.com/sipeed/MaixCDK/blob/master/docs/doc/convention/protocol.md) （[例程](https://github.com/sipeed/MaixPy/tree/main/examples/communication/protocol)）,这样用户可以直接当成串口模块使用，比如人脸检测应用，可以在检测到人脸后通过串口输出坐标。"},"/maixpy/doc/zh/vision/qrcode.html":{"title":"MaixPy 二维码识别","content":" title: MaixPy 二维码识别 update: date: 2024 04 03 author: lxowalle version: 1.0.0 content: 初版文档 阅读本文前，确保已经知晓如何开发MaixPy，详情请阅读[MaixVision MaixPy 编程 + 图形化积木编程](../basic/maixvision.html) ## 简介 本文介绍如何使用MaixPy来识别二维码 ## 使用 MaixPy 识别二维码 MaixPy的 `maix.image.Image`中提供了`find_qrcodes`方法，用来识别二维码。 ### 如何识别二维码 一个简单的示例，实现识别二维码并画框 ```python from maix import image, camera, display cam camera.Camera(320, 240) disp display.Display() while 1: img cam.read() qrcodes img.find_qrcodes() for qr in qrcodes: corners qr.corners() for i in range(4): img.draw_line(corners[i][0], corners[i][1], corners[(i + 1) % 4][0], corners[(i + 1) % 4][1], image.COLOR_RED) img.draw_string(qr.x(), qr.y() 15, qr.payload(), image.COLOR_RED) disp.show(img) ``` 步骤： 1. 导入image、camera、display模块 ```python from maix import image, camera, display ``` 2. 初始化摄像头和显示 ```python cam camera.Camera(320, 240) # 初始化摄像头，输出分辨率320x240 RGB格式 disp display.Display() ``` 3. 从摄像头获取图片并显示 ```python while 1: img cam.read() disp.show(img) ``` 4. 调用`find_qrcodes`方法识别摄像头中的二维码 ```python qrcodes img.find_qrcodes() ``` `img`是通过`cam.read()`读取到的摄像头图像，当初始化的方式为`cam camera.Camera(320, 240)`时，`img`对象是一张分辨率为320x240的RGB图。 `img.find_qrcodes`用来寻找二维码，并将查询结果保存到`qrocdes`，以供后续处理 5. 处理识别二维码的结果并显示到屏幕上 ```python for qr in qrcodes: corners qr.corners() for i in range(4): img.draw_line(corners[i][0], corners[i][1], corners[(i + 1) % 4][0], corners[(i + 1) % 4][1], image.COLOR_RED) img.draw_string(qr.x(), qr.y() 15, qr.payload(), image.COLOR_RED) ``` `qrcodes`是通过`img.find_qrcodes()`查询二维码的结果，如果找不到二维码则`qrcodes`内部为空 `qr.corners()`用来获取已扫描到的二维码的四个顶点坐标，`img.draw_line()`利用这四个顶点坐标画出二维码的形状 `img.draw_string`用来显示二维码的内容和位置等信息，其中`qr.x()`和`qr.y()`用来获取二维码左上角坐标x和坐标y，`qr.payload()`用来获取二维码的内容 ### 常用参数说明 列举常用参数说明，如果没有找到可以实现应用的参数，则需要考虑是否使用其他算法实现，或者基于目前算法的结果扩展所需的功能 参数 说明 示例 roi 设置算法计算的矩形区域，roi [x, y, w, h]，x，y表示矩形区域左上角坐标，w，h表示矩形区域的宽度和高度，默认为整张图片 计算坐标为(50,50)，宽和高为100的区域<br />```img.find_qrcodes(roi [50, 50, 100, 100])``` 本文介绍常用方法，更多 API 请看 API 文档的 [image](../../../api/maix/image.html) 部分。"},"/maixpy/doc/zh/vision/camera.html":{"title":"MaixPy 摄像头使用","content":" title: MaixPy 摄像头使用 update: date: 2024 04 03 author: neucrack version: 1.0.0 content: 初版文档 ## 简介 对于 MaixCAM 默认搭载了 GC4653 摄像头，或者可选的 OS04A10 摄像头或者全局快门摄像头，甚至是 HDMI 转 MIPI 模块，都可以直接用简单的 API 调用。 ## API 文档 本文介绍常用方法，更多 API 使用参考 [maix.camera](/api/maix/camera.html) 模块的文档。 ## 摄像头切换 不同的摄像头使用不同的驱动，需要在系统中选择正确的驱动。 TODO：如何切换摄像头，比如 GC4653 和 OS04A10 之间的切换。 ## 从摄像头获取图像 使用 MaixPy 轻松获取： ```python from maix import camera cam camera.Camera(640, 480) while 1: img cam.read() print(img) ``` 这里我们从`maix`模块导入`camera`模块，然后创建一个`Camera`对象，指定图像的宽度和高度。然后在一个循环中不断读取图像， 默认出的图为`RGB`格式，如果需要`BGR`格式，其它格式请看 API 文档。 ## 跳过 开头的帧 摄像头初始化的一小段时间，可能图像采集还没稳定出现奇怪的画面，可以通过`skip_frames`函数跳过开头的几帧： ```python cam camera.Camera(640, 480) cam.skip_frames(30) # 跳过开头的30帧 ``` ## 显示图像 MaixPy 提供了`display`模块，可以方便的显示图像： ```python from maix import camera, display cam camera.Camera(640, 480) disp display.Display() while 1: img cam.read() disp.show(img) ```"},"/maixpy/doc/zh/vision/find_blobs.html":{"title":"MaixPy 寻找色块","content":" title: MaixPy 寻找色块 update: date: 2024 04 03 author: neucrack version: 1.0.0 content: 初版文档 date: 2024 04 03 author: lxowalle version: 1.0.1 content: 添加寻找色块的详细用法 阅读本文前，确保已经知晓如何开发MaixPy，详情请阅读[MaixVision MaixPy 编程 + 图形化积木编程](../basic/maixvision.html) ## 简介 本文将介绍如何使用MaixPy来寻找色块，以及如何使用MaixCam的默认应用程序寻找色块。 在视觉应用中，寻找色块是一个非常常见的需求，比如机器人找色块，自动化生产线找色块等等，即需要识别画面中的特定的颜色区域，获取这个区域的位置和大小等信息。 ## 使用 MaixPy 寻找色块 MaixPy的 `maix.image.Image`中提供了`find_blobs`方法，可以方便的找色块。 ### 如何寻找色块 一个简单的示例，实现寻找色块并画框 ```python from maix import image, camera, display cam camera.Camera(320, 240) disp display.Display() # 根据色块颜色选择对应配置 thresholds [[0, 80, 40, 80, 10, 80]] # red # thresholds [[0, 80, 120, 10, 0, 30]] # green # thresholds [[0, 80, 30, 100, 120, 60]] # blue while 1: img cam.read() blobs img.find_blobs(thresholds, pixels_threshold 500) for blob in blobs: img.draw_rect(blob[0], blob[1], blob[2], blob[3], image.COLOR_GREEN) disp.show(img) ``` 步骤： 1. 导入image、camera、display模块 ```python from maix import image, camera, display ``` 2. 初始化摄像头和显示 ```python cam camera.Camera(320, 240)\t# 初始化摄像头，输出分辨率320x240 RGB格式 disp display.Display() ``` 3. 从摄像头获取图片并显示 ```python while 1: img cam.read() disp.show(img) ``` 4. 调用`find_blobs`方法寻找摄像头图片中的色块，并画到屏幕上 ```python blobs img.find_blobs(thresholds, pixels_threshold 500) for blob in blobs: img.draw_rect(blob[0], blob[1], blob[2], blob[3], image.COLOR_GREEN) ``` `img`是通过`cam.read()`读取到的摄像头图像，当初始化的方式为`cam camera.Camera(320, 240)`时，`img`对象是一张分辨率为320x240的RGB图。 `img.find_blobs`用来寻找色块， `thresholds` 是一个颜色阈值列表，每个元素是一个颜色阈值，同时找到多个阈值就传入多个，每个颜色阈值的格式为 `[L_MIN, L_MAX, A_MIN, A_MAX, B_MIN, B_MAX]`，这里的 `L`、`A`、`B` 是`LAB`颜色空间的三个通道，`L` 通道是亮度，`A` 通道是红绿通道，`B` 通道是蓝黄通道。`pixels_threshold`是一个像素点数量的阈值，用来过滤一些不需要的小色块。 `img.draw_rect`用来画色块框，`blob[0]`、`blob[1]`、`blob[1]`、`blob[1]`分别代表色块左上角坐标x，色块左上角坐标y，色块宽度w和色块高度h ### 常用参数说明 列举常用参数说明，如果没有找到可以实现应用的参数，则需要考虑是否使用其他算法实现，或者基于目前算法的结果扩展所需的功能 参数 说明 示例 thresholds 基于lab颜色空间的阈值，threshold [[l_min, l_max, a_min, a_max, b_min, b_max]]，分别表示：<br />亮度范围为[l_min, l_max]\\<br />绿色到红色的分量范围为[l_min, l_max]<br />蓝色到黄色的分量范围为[b_min, b_max]<br />可同时设置多个阈值 设置两个阈值来检测红色和绿色<br />```img.find_blobs(threshold [[0, 80, 40, 80, 10, 80], [0, 80, 120, 10, 0, 30]])```<br />红色阈值为[0, 80, 40, 80, 10, 80]<br />绿色阈值为[0, 80, 120, 10, 0, 30] invert 使能阈值反转，使能后传入阈值与实际阈值相反，默认为False 使能阈值反转<br />```img.find_blobs(invert True)``` roi 设置算法计算的矩形区域，roi [x, y, w, h]，x，y表示矩形区域左上角坐标，w，h表示矩形区域的宽度和高度，默认为整张图片 计算坐标为(50,50)，宽和高为100的区域<br />```img.find_blobs(roi [50, 50, 100, 100])``` area_threshold 过滤像素面积小于area_threshold的色块，单位为像素点，默认为10。该参数可用于过滤一些无用的小色块 过滤面积小于1000的色块<br />```img.find_blobs(area_threshold 1000)``` pixels_threshold 过滤有效像素点小于pixels_threshold的色块，默认为10。该参数可用于过滤一些无用的小色块 过滤有效像素点小于1000的色块<br />```img.find_blobs(pixels_threshold 1000)``` 本文介绍常用方法，更多 API 请看 API 文档的 [image](../../../api/maix/image.html) 部分。 ## 使用寻找色块APP 为了快速验证寻找色块的功能，可以先使用MaixCam提供的寻找色块应用程序来体验寻找色块的效果。 ### 使用方法 打开设备，选择`找色块`应用，然后在下方选择要识别的颜色，或者自定义颜色，即可以识别到对应的颜色了，同时串口也会输出识别到的坐标和颜色信息。 <video src \"/static/video/find_blobs.mp4\" controls \"controls\" width \"100%\" height \"auto\"></video> ### 详细说明 APP界面参考如下： ![](../../../static/image/find_blobs_app.jpg) #### 使用默认配置 寻找色块APP默认提供了`red、green、blue、user`四种配置，其中`red、green和blue`用来`寻找红色、绿色和蓝色的色块`，`user`主要提供给`用户自定义寻找色块`，自定义配置的方法见下文。快速体验时通过`点击`界面下方`按钮`即可切换到对应配置， #### 寻找自定义色块 APP提供两种方式来寻找自定义的色块：通过自适应LAB阈值寻找和手动设置LAB阈值寻找 ##### 1. 自适应LAB阈值寻找色块 操作方法： 1. `点击`左下角`选项图标`，进入配置模式 2. 将`摄像头对准`需要`寻找的物体`，`点击`屏幕上的`目标物体`，此时`左侧`会显示该物体对应颜色的`矩形框`，并显示该物体颜色的LAB值。 3. 点击出现的`矩形框`，系统将会`自动设置`LAB阈值，此时画面将会画出该物体边缘。 ##### 2. 手动设置LAB阈值寻找色块 手动设置可以更精确的找到目标色块。 操作方法： 1. `点击`左下角`选项图标`，进入配置模式 2. 将`摄像头对准`需要`寻找的物体`，`点击`屏幕上的`目标物体`，此时`左侧`会显示该物体对应颜色的`矩形框`，并显示该物体颜色的`LAB值`。 3. 点击下方选项`L Min，L Max，A Min，A Max，B Min，B Max`，点击后右侧会出现滑动条来设置该选项值。这些值分别对应LAB颜色格式的L通道、A通道和B通道的最小值和最大值 4. 参考步骤2计算的物体颜色的`LAB值`，将`L Min，L Max，A Min，A Max，B Min，B Max`调整到合适的值，即可识别到对应的色块。 例如`LAB (20, 50, 80)`，由于`L 20`，为了适配一定范围让`L Min 10`，`L Max 30`;同理，由于`A 50`，让`A Min 40`，`A Max 60`; 由于`B 80`，让`B Min 70`，`B Max 90`。 #### 通过串口协议获取检测数据 寻找色块APP支持通过串口（默认波特率为115200）上报检测到的色块信息。 由于上报信息只有一条，这里直接用示例来说明上报信息的内容。 例如上报信息为： ```shell AA CA AC BB 14 00 00 00 E1 08 EE 00 37 00 15 01 F7 FF 4E 01 19 00 27 01 5A 00 A7 20 ``` `AA CA AC BB`：协议头部，内容固定 `14 00 00 00`：数据长度，除了协议头部和数据长度外的总长度 `E1`：标志位，用来标识串口消息标志 `08`：命令类型，对于寻找色块APP应用该值固定为0x08 `EE 00 37 00 15 01 F7 FF 4E 01 19 00 27 01 5A 00`：已找到色块的四个顶点坐标，每个值用小端格式的2字节表示。`EE 00`和`37 00`表示第一个顶点坐标为(238, 55)，`15 01`和`F7 FF`表示第二个顶点坐标为(277, 9)，`4E 01`和`19 00`表示第三个顶点坐标为(334, 25)，`27 01`和`5A 00`表示第四个顶点坐标为(295, 90)。 `A7 20`：CRC 校验值，用以校验帧数据在传输过程中是否出错 ## 关于LAB颜色空间 LAB颜色空间和RGB颜色空间一样是一种表示颜色的方法，LAB可以表示人眼能看到的所有颜色。如果需要了解LAB可以去网络上搜索相关文章，那样更详细，而对于你应该只需要了解为什么选用LAB对于MaixPy的优势。 LAB对于MaixPy的优势： 1. LAB颜色空间的色域比RGB都要大，因此完全可以替换RGB。 2. LAB颜色空间下，由于L通道是亮度通道，我们常常设置到较大的范围即可（常用[0,80]），而编写代码时主要关注是A通道和B通道，这样可以减少大量的时间在纠结颜色阈值如何选择的问题上。 3. LAB颜色空间的颜色感知更均匀，更容易用代码调试。例如，对于只需要寻找红色色块，可以固定L通道和B通道值，只需要调整A通道的值即可（这是在颜色精度要求不高的情况下）;如果是RGB通道则基本需要R、G、B三个通道同时变动才能找到合适的阈值。"},"/maixpy/doc/zh/vision/classify.html":{"title":"MaixPy 使用 AI 模型进行物体分类","content":" title: MaixPy 使用 AI 模型进行物体分类 ## 物体分类概念 比如眼前有两张图片，一张图里面是苹果，另一张是飞机，物体分类的任务就是把两张图分别依次输入给 AI 模型，模型会依次输出两个结果，一个是苹果，一个是飞机。 ## MaixPy 中使用物体分类 MaixPy 默认提供了 `imagenet` 数据集训练得到的 `1000`分类模型，可以直接使用： ```python from maix import camera, display, image, nn classifier nn.Classifier(model \"/root/models/mobilenetv2.mud\") cam camera.Camera(classifier.input_width(), classifier.input_height(), classifier.input_format()) dis display.Display() while 1: img cam.read() res classifier.classify(img) max_idx, max_prob res[0] msg f\"{max_prob:5.2f}: {classifier.labels[max_idx]}\" img.draw_string(10, 10, msg, image.COLOR_RED) dis.show(img) ``` 效果视频: <video playsinline controls autoplay loop muted preload src \"https://wiki.sipeed.com/maixpy/static/video/classifier.mp4\" type \"video/mp4\"> Classifier Result video </video> 这里使用了摄像头拍摄图像，然后传给 `classifier`进行识别，得出结果后，将结果显示在屏幕上。 更多 API 使用参考 [maix.nn](/api/maix/nn.html) 模块的文档。 ## 训练自己的分类模型 请到[MaixHub](https://maixhub.com) 学习并训练分类模型，创建项目时选择`分类模型`即可。"},"/maixpy/doc/zh/vision/image_ops.html":{"title":"MaixPy 图像基础操作","content":" title: MaixPy 图像基础操作 update: date: 2024 04 03 author: neucrack version: 1.0.0 content: 初版文档 ## 简介 视觉应用中图像占据非常重要的位置，不管是图片还是视频，因为视频本质上就是一帧帧的图像，所以图像处理是视觉应用的基础。 ## API 文档 本文介绍常用方法， 更多 API 参考 [maix.image](/api/maix/image.html) 模块的文档。 ## 图像格式 MaixPy 提供基础图像模块`image`，里面最重要的就是`image.Image`类，用于图像的创建以及各种图像基础操作，以及图像加载和保存等。 图像格式有很多，一般我们用`image.Format.FMT_RGB888` 或者 `image.Format.FMT_RGBA8888` 或者 `image.Format.FMT_GRAYSCALE`或者`image.Format.FMT_BGR888`等。 大家知道 `RGB` 三色可以合成任意颜色，所以一般情况下我们使用 `image.Format.FMT_RGB888`就足够， `RGB888` 在内存中是 `RGB packed` 排列，即在内存中的排列： `像素1_红色, 像素1_绿色, 像素1_蓝色, 像素2_红色, 像素2_绿色, 像素2_蓝色, ...` 依次排列。 ## 创建图像 创建图像很简单，只需要指定图像的宽度和高度以及图像格式即可： ```python from maix import image img image.Image(320, 240, image.Format.FMT_RGB888) print(img) print(img.width(), img.height(), img.format()) ``` `320` 是图像的宽度，`240` 是图像的高度，`image.Format.FMT_RGB888` 是图像的格式，格式参数可以省略，默认是`image.Format.FMT_RGB888`。 这里通过`img.width()`、`img.height()`、`img.format()`可以获取图像的宽度、高度和格式。 ## 显示到屏幕 MaixPy 提供了`maix.display.Display`类，可以方便的显示图像： ```python from maix import image, display disp display.Display() img image.Image(320, 240, image.Format.FMT_RGB888) disp.show(img) ``` 注意这里因为没有图像数据，所以显示的是黑色的图像，修改画面看后文。 ## 从文件系统读取图像 MaixPy 提供了`maix.image.load`方法，可以从文件系统读取图像： ```python from maix import image img image.load(\"/root/image.jpg\") print(img) ``` 注意这里`/root/image.jpg` 是提前传输到了板子上的，方法可以看前面的教程。 可以支持 `jpg` 和 `png` 格式的图像。 ## 保存图像到文件系统 MaixPy 的`maix.image.Image`提供了`save`方法，可以保存图像到文件系统： ```python from maix import image img image.Image(320, 240, image.Format.FMT_RGB888) # do something with img img.save(\"/root/image.jpg\") ``` ## 画框 `image.Image`提供了`draw_rect`方法，可以在图像上画框： ```python from maix import image img image.Image(320, 240, image.Format.FMT_RGB888) img.draw_rect(10, 10, 100, 100, image.Color.from_rgb(255, 0, 0)) ``` 这里的参数依次是：`x`, `y`, `w`, `h`, `color`，`x` 和 `y` 是框的左上角坐标，`w` 和 `h` 是框的宽度和高度，`color` 是框的颜色，可以使用`image.Color.from_rgb`方法创建颜色。 可以用`thickness`指定框的线宽，默认是`1`， 也可以画实心框，传参 `thickness 1` 即可： ```python from maix import image img image.Image(320, 240, image.Format.FMT_RGB888) img.draw_rect(10, 10, 100, 100, (255, 0, 0), thickness 1) ``` ## 写字符串 `image.Image`提供了`draw_string`方法，可以在图像上写字： ```python from maix import image img image.Image(320, 240, image.Format.FMT_RGB888) img.draw_string(10, 10, \"Hello MaixPy\", image.Color.from_rgb(255, 0, 0)) ``` 这里的参数依次是：`x`, `y`, `text`, `color`，`x` 和 `y` 是文字的左上角坐标，`text` 是要写的文字，`color` 是文字的颜色，可以使用`image.Color.from_rgb`方法创建颜色。 还可以放大字体，传参 `scale` 即可： ```python img.draw_string(10, 10, \"Hello MaixPy\", image.Color.from_rgb(255, 0, 0), scale 2) ``` 获取字体的宽度和高度： ```python w, h img.string_size(\"Hello MaixPy\", scale 2) print(w, h) ``` **注意**这里`scale`是放大倍数，默认是`1`，和`draw_string`应该保持一致。 ## 画线 `image.Image`提供了`draw_line`方法，可以在图像上画线： ```python from maix import image img image.Image(320, 240, image.Format.FMT_RGB888) img.draw_line(10, 10, 100, 100, image.Color.from_rgb(255, 0, 0)) ``` 这里的参数依次是：`x1`, `y1`, `x2`, `y2`, `color`，`x1` 和 `y1` 是线的起点坐标，`x2` 和 `y2` 是线的终点坐标，`color` 是线的颜色，可以使用`image.Color.from_rgb`方法创建颜色。 ## 画圆 `image.Image`提供了`draw_circle`方法，可以在图像上画圆： ```python from maix import image img image.Image(320, 240, image.Format.FMT_RGB888) img.draw_circle(100, 100, 50, image.Color.from_rgb(255, 0, 0)) ``` 这里的参数依次是：`x`, `y`, `r`, `color`，`x` 和 `y` 是圆心坐标，`r` 是半径，`color` 是圆的颜色，可以使用`image.Color.from_rgb`方法创建颜色。 ## 缩放图像 `image.Image`提供了`resize`方法，可以缩放图像： ```python from maix import image img image.Image(320, 240, image.Format.FMT_RGB888) img_new img.resize(160, 120) print(img, img_new) ``` 注意这里`resize`方法返回一个新的图像对象，原图像不变。 ## 剪裁图像 `image.Image`提供了`crop`方法，可以剪裁图像： ```python from maix import image img image.Image(320, 240, image.Format.FMT_RGB888) img_new img.crop(10, 10, 100, 100) print(img, img_new) ``` 注意这里`crop`方法返回一个新的图像对象，原图像不变。 ## 旋转图像 `image.Image`提供了`rotate`方法，可以旋转图像： ```python from maix import image img image.Image(320, 240, image.Format.FMT_RGB888) img_new img.rotate(90) print(img, img_new) ``` 注意这里`rotate`方法返回一个新的图像对象，原图像不变。 ## 拷贝图像 `image.Image`提供了`copy`方法，可以拷贝一份独立的图像： ```python from maix import image img image.Image(320, 240, image.Format.FMT_RGB888) img_new img.copy() print(img, img_new) ``` ## 仿射变换 `image.Image`提供了`affine`方法，可以进行仿射变换，即提供当前图中三个及以上的点坐标，以及目标图中对应的点坐标，可以自动进行图像的旋转、缩放、平移等操作变换到目标图像： ```python from maix import image img image.Image(320, 240, image.Format.FMT_RGB888) img_new img.affine([(10, 10), (100, 10), (10, 100)], [(10, 10), (100, 20), (20, 100)]) print(img, img_new) ``` 更多参数和用法请参考 API 文档。 ## 画关键点 `image.Image`提供了`draw_keypoints`方法，可以在图像上画关键点： ```python from maix import image img image.Image(320, 240, image.Format.FMT_RGB888) keypoints [(10, 10), (100, 10), (10, 100)] img.draw_keypoints(keypoints, image.Color.from_rgb(255, 0, 0), size 10, thickness 1, fill False) ``` 在坐标`(10, 10)`、`(100, 10)`、`(10, 100)`画三个红色的关键点，关键点的大小是`10`，线宽是`1`，不填充。 ## 画十字 `image.Image`提供了`draw_cross`方法，可以在图像上画十字： ```python from maix import image img image.Image(320, 240, image.Format.FMT_RGB888) img.draw_cross(100, 100, image.Color.from_rgb(255, 0, 0), size 5, thickness 1) ``` 在坐标`(100, 100)`画一个红色的十字，十字的延长大小是`5`，所以线段长度为`2 * size + thickness`, 线宽是`1`。 ## 画箭头 `image.Image`提供了`draw_arrow`方法，可以在图像上画箭头： ```python from maix import image img image.Image(320, 240, image.Format.FMT_RGB888) img.draw_arrow(10, 10, 100, 100, image.Color.from_rgb(255, 0, 0), thickness 1) ``` 在坐标`(10, 10)`画一个红色的箭头，箭头的终点是`(100, 100)`，线宽是`1`。 ## 画图 `image.Image`提供了`draw_image`方法，可以在图像上画图： ```python from maix import image img image.Image(320, 240, image.Format.FMT_RGB888) img2 image.Image(100, 100, image.Format.FMT_RGB888) img2.draw_rect(10, 10, 90, 90, image.Color.from_rgb(255, 0, 0)) img.draw_image(10, 10, img2) ``` ## 转换格式 `image.Image`提供了`to_format`方法，可以转换图像格式： ```python from maix import image img image.Image(320, 240, image.Format.FMT_RGB888) img_new img.to_format(image.Format.FMT_BGR888) print(img, img_new) img_jpg img.to_format(image.Format.FMT_JPEG) print(img, img_new) ``` 注意这里`to_format`方法返回一个新的图像对象，原图像不变。 ## 和 Numpy/OpenCV 格式互相转换 另外还可以转换成`numpy`数组，这样就能给`numpy`和`opencv`等库使用： ```python from maix import image img image.Image(320, 240, image.Format.FMT_RGB888) img_np image.image2cv(img) img2 image.cv2image(img_np) print(type(img_np), img_np, img_np.shape) print(type(img2), img2) ``` ## 和 bytes 数据互相转换 `image.Image`提供了`to_bytes`方法，可以转换图像为`bytes`数据： ```python from maix import image img image.Image(320, 240, image.Format.FMT_RGB888) data img.to_bytes() print(type(data), len(data), img.data_size()) img2 image.Image(320, 240, image.Format.FMT_RGB888, data) print(img2) ``` 这里`to_bytes`获得一个新的`bytes`对象，是独立的内存，不会影响原图。 `image.Image`构造函数中传入`data`参数可以直接从`bytes`数据构造图像对象，注意新的图像也是独立的内存，不会影响到`data`。 因为涉及到内存拷贝，所以这个方法比较耗时，不建议频繁使用。 > 如果你想用不拷贝的方式优化程序（不建议轻易使用，写不好代码会导致程序容易崩溃，），请看 API 文档。 ## 更多基础 API 使用方法 更多 API 使用方法请参考 [maix.image](/api/maix/image.html) 模块的文档。"},"/maixpy/doc/zh/vision/maixhub_train.html":{"title":"使用 MaixHub 在线训练 AI 模型给 MaixPy 使用","content":" title: 使用 MaixHub 在线训练 AI 模型给 MaixPy 使用 update: date: 2024 04 03 author: neucrack version: 1.0.0 content: 初版文档 ## 简介 MaixHub 提供了在线训练 AI 模型的功能，可以直接在浏览器中训练模型，不需要购买昂贵的机器，不需要搭建复杂的开发环境，也不需要写代码，非常适合入门，也适合懒得翻代码的老手。 ## 使用 MaixHub 训练模型的基本步骤 ### 确认要识别的数据类型和模型类型 要训练一个 AI 模型，需要先确定是什么数据和模型，目前 MaixHub（2024.4）提供了图像数据的`物体分类模型`和`物体检测模型`，都是图像识别模型， `物体分类模型` 比 `物体检测模型` 更简单，因为物体检测需要标注物体在图中的位置，会比较麻烦，物体分类则只需要给出图像中是什么，不需要坐标，所以更简单， 如果是初学者建议先从物体分类开始。 ### 采集数据 如前面的 AI 基础所说，要训练模型，必须准备训练用的数据集让 AI 学习，对于图像训练，我们需要创建一个数据集，并且上传图片到数据集。 保证设备已经连接网络（WiFi）。 打开设备上的 MaixHub 应用选择 采集数据 来拍照并一键上传到 MaixHub。需要先在 MaixHub 创建数据集，然后点击 设备 上传数据，会出现一个 二维码，设备扫描二维码来与MaixHub 建立连接。 注意要分清训练集和验证集的区别，要想实机运行的效果和训练效果相当，验证集的数据一定要和实机运行拍摄的图像质量一样，训练集也建议用设备拍摄的，如果要用网上的图片，一定只能用在训练集，不要用在验证集，因为数据量小，数据集与实机运行越接近越好。 ### 标注数据 对于分类模型，在上传的时候就顺便已经标注好了，即上传时选择好了图片属于那个分类。 对于目标检测模型，上传完成后需要进行手动标注，即在每一张图中框出要被识别物体的坐标大小和分类。 这个标注过程你也可以选择自己在自己的电脑中离线用比如 labelimg 这样的软件标注完毕后使用数据集中的导入功能导入到 MaixHub。 标注时善用快捷键标注起来会更快，后面MaixHub 也会增加更多辅助标注和自动标注工具（目前在上传视频处有自动标注工具也可以尝试使用）。 ### 训练模型 选择训练参数训练，选择对应的设备平台，选择 maixcam，等待排队训练，可以实时看到训练进度，等待完成即可。 ### 部署模型 训练完成后，可以设备的 MaixHub 应用中选择 部署 功能，扫码进行部署。 设备开会自动下载模型并且运行起来，模型会被存在本地，后面也能选择再次运行。 如果你觉得识别效果很不错，可以一键分享到模型库让更多人使用。 ## 使用方法 请到 [MaixHub](https://maixhub.com) 注册账号，然后登录，主页有视频教程，学习即可。 注意教程如果是使用了 M2dock 这个开发板，和 MaixCAM也是类似的，只是设备（板子）上使用的 MaixHub 应用可能稍微有点区别，大体上是相同的，请注意举一反三。"},"/maixpy/doc/zh/index.html":{"title":"MaixPy 快速开始","content":" title: MaixPy 快速开始 <div style \"font size: 1.2em;border: 2px solid green; border color:#c33d45;padding:1em; text align:center; background: #c33d45; color: white\"> <div> <span>MaixPy 唯一官网:</span> <a target \"_blank\" style \"color: #ffe0e0\" href \"https://wiki.sipeed.com/maixpy\"> wiki.sipeed.com/maixpy </a> <br> <div style \"height:0.4em\"></div> <span>MaixPy 例程和源码:</span> <a target \"_blank\" style \"color: #ffe0e0\" href \"https://github.com/sipeed/MaixPy\"> github.com/sipeed/MaixPy </a> </div> <div style \"padding: 1em 0 0 0\"> <a target \"_blank\" style \"color: white; font size: 0.9em; border radius: 0.3em; padding: 0.5em; background color: #a80202\" href \"https://item.taobao.com/item.htm?id 784724795837\">淘宝</a> <a target \"_blank\" style \"color: white; font size: 0.9em; border radius: 0.3em; padding: 0.5em; background color: #a80202\" href \"https://www.aliexpress.com/store/911876460\">速卖通</a> </div> </div> <br> > 关于 MaixPy 介绍请看 [MaixPy 官网首页](../../index.html) ## 获得 MaixCAM 设备 在 [Sipeed 淘宝](https://item.taobao.com/item.htm?id 784724795837) 或者 [Sipeed 速卖通](https://www.aliexpress.com/store/911876460) 店铺购买 <a href \"https://wiki.sipeed.com/maixcam\" target \"_blank\">MaixCAM</a> 开发板。 **建议购买带 `TF 卡`、`摄像头`、`2.3寸触摸屏`、`外壳`、`Type C 数据线`、 `Type C一转二小板`、`4P串口座子+线`的套餐**，方便后续使用和开发，**后面的教程都默认你已经有了这些配件**（包括屏幕）。 如果你没有购买 TF 卡，则你需要**自备**一个 **TF 读卡器**用来烧录系统。 >! 注意，目前只支持 MaixCAM 开发板，其它同型号芯片的开发板均不支持，包括 Sipeed 的同型号芯片开发板，请注意不要买错造成不必要的时间和金钱浪费。 ## 上手配置 ### 准备 TF 镜像卡和插入到设备 如果你买的套餐里面有 TF 卡，里面已经有出厂镜像了，如果出厂时 TF 卡没有安装到设备，需要先小心打开外壳（注意里面有排线连接不要扯断了），然后插入 TF 卡。另外因为出厂的固件可能比较老旧，可以插按照[升级和烧录系统](https://wiki.sipeed.com/maixpy/doc/zh/basic/os.html)先将系统升级到最新版本。 如果没买 TF 卡，则需要将系统烧录进自备的 TF 卡中，烧录方法请看[升级和烧录系统](./basic/os.html)，然后再安装到板子。 ### 上电开机 使用 `Type C` 数据线连接 `MaixCAM` 设备给设备供电，等待设备开机，开机会进入功能选择界面。 ![maixcam_font](../../static/image/maixcam_font.png) 如果屏幕没有显示 * 请确认购买了配套的 TF 卡，如果确认有 TF 卡，并且已经插入到设备，可以**尝试[更新到最新的系统](./basic/os.html)**。 * 如果你没有购买 TF 卡套餐，你需要按照[升级和烧录系统](./basic/os.html)的方法烧录最新的系统到 TF 卡。 * 另外请确认屏幕和摄像头的排线没有松动，屏幕的排线在拆开外壳时很容易脱落，需要注意。 ### 联网 首次运行需要连接网络，后面会激活设备和使用 IDE 会用到。 * 设备上点击 `设置`(`Settings`)，选择`WiFi`，点击 `扫描` 按钮开始扫描周围 `WiFi`， 可以多次点击刷新列表。 * 找到你的 WiFi 热点，如果没有路由器可以用手机开一个热点。 * 输入密码点击`连接`按钮进行连接。 * 等待获取到 `IP` 地址，这可能需要 `10` 到 `30` 秒，如果界面没有刷新可以退出`WiFi`功能重新进入查看，或者在`设置` > `设备信息` 中也可以看到 `IP` 信息。 ### 升级运行库 **这一步很重要 ！！！** 这一步如果不做好，其它应用和功能可能无法运行（比如闪退等）。 * 首先保证上一步连接 WiFi 已经完成，并且获取到 IP 地址能访问公网。 * 设备上点击 `设置`(`Settings`)，选择`安装运行库`。 * 安装完成后可以看到更新到了最新版本，然后退出即可。 如果显示`Request failed` 或者`请求失败`，请先检查网络是否已经连接，需要能连接到互联网，如果还不行，请拍照联系客服处理即可。 ### 使用内置应用 内置了很多应用，比如 找色块，AI 检测器，巡线等等，找色块举例： <video playsinline controls autoplay loop muted preload class \"pl 6 pb 4 self end\" src \"/static/video/find_blobs.mp4\" type \"video/mp4\"> Classifier Result video </video> 其它的请自行摸索，以后还会更新更多应用，使用文档以及应用更新请看 [MaixHub 应用商店](https://maixhub.com/app) 。 **注意：应用只包含了 MaixPy 能实现的一部分功能，使用 MaixPy 能创造更多功能**。 ## 作为串口模块使用 > 如果是想把设备当成主控使用（或者你还不懂什么是串口模块）可以跳过这一步。 内置的各种应用可以直接当成串口模块使用，比如`找色块`、`找人脸`、`找二维码`等等， 使用方法： * 硬件连接： 可以给设备接上`Type C一转二小板`，这样我们就能将设备通过串口连接到你的主控上了，比如`Arduino`、`树莓派`、`STM32`等等。 * 打开你想用的应用，比如二维码识别，当设备扫描到二维码就会通过串口把结果发送给你的主控了。 > 发送的串口波特率是 `115200`，数据格式是 `8N1`，协议遵循 [Maix 串口通信协议标准](https://github.com/sipeed/MaixCDK/blob/master/docs/doc/convention/protocol.md)，可以在[MaixHub APP](https://maixhub.com/app) 找到对应的应用介绍查看协议。 ## 准备连接电脑和设备 为了后面电脑（PC）能和 设备（MaixCAM）通信，我们要让它们在同一个局域网内，提供了两种方式： * **方法一 (强烈推荐)**：无线连接， 设备使用 WiFi 连接到电脑连接的同一个路由器或者 WiFi 热点下： 在设备的`设置 > WiFi 设置`中连接到你的 WiFi 即可。 * **方法二**：有线连接， 设备通过 USB 线连接到电脑，设备会虚拟成一个 USB 网卡，这样和电脑就通过 USB 在同一局域网了。 > 方案二因为要用 USB 和驱动，可能会遇到一些问题，所以推荐直接用 WiFi 开始，可以在 [FAQ](./faq.html) 中找常见问题。 .. details::方案二在不同电脑系统中有不同设置方法，点击展开 * **Linux**: 无需额外设置，插上 USB 线即可， 使用 `ifconfig` 或者 `ip addr` 查看到 `usb0` 网卡，**注意** 这里看到的 ip 比如 `10.131.167.100` 是电脑的 ip, 设备的 ip 是最后一位改为`1` 即 `10.131.167.1`。 * **Windows**: 可以先确认`网络适配器`里面是否多了一个 RNDIS 设备，如果有就直接能用。否则需要手动安装 RNDIS 网卡驱动： * 打开电脑的`设备管理器`。 * 然后在`其它设备`里面找个一个带问号的 RNDIS 设备，右键选择`更新驱动程序`。 * 选择`浏览计算机以查找驱动程序`，然后选择`让我从计算机上的可用驱动程序列表中选择`。 * 选择`网络适配器`，然后点击`下一步`。 * 左边选择`Microsoft`，右边选择`远程 NDIS 兼容设备`，然后点击`下一步`, 选择`是`。 * 装好后的效果 ![RNDIS](../../static/image/rndis_windows.jpg) * **MacOS**: 无需额外设置，插上 USB 线即可， 使用 `ifconfig` 或者 `ip addr` 查看到 `usb0` 网卡，**注意** 这里看到的 ip 比如 `10.131.167.100` 是电脑的 ip, 设备的 ip 是最后一位改为`1` 即 `10.131.167.1`。 ## 开发环境准备 * 下载 [MaixVision](https://wiki.sipeed.com/maixvision) 并安装。 * 使用 Type C 连接设备和电脑，打开 MaixVision，点击左下角的`“连接”`按钮，会自动搜索设备，稍等一下就能看到设备，点击设备有点的连接按钮以连接设备。 如果**没有扫描到设备**，你也可以在**设备**的 `设置 > 设备信息` 中查看设备的 IP 地址手动输入， 也可以在 [FAQ](./faq.html) 中找到解决方法。 **连接成功后，设备的功能选择界面会消失，屏幕会黑屏，释放了所有硬件资源，如果仍然有画面显示，可以断开连接重连。** 这里有 MaixVision 的使用示例视频: <video style \"width:100%\" controls muted preload src \"/static/video/maixvision.mp4\"></video> ## 运行例程 点击 MaixVision 左侧的`示例代码`，选择一个例程，点击左下角`运行`按钮将代码发送到设备上运行。 比如： * `hello_maix.py`，点击`运行`按钮，就能看到 MaixVision 终端有来自设备打印的消息，以及右上角出现了图像。 * `camera_display.py`，这个例程会打开摄像头并在屏幕上显示摄像头的画面。 ```python from maix import camera, display, app disp display.Display() # 构造一个显示对象，并初始化屏幕 cam camera.Camera(640, 480) # 构造一个摄像头对象，手动设置了分辨率为 640x480, 并初始化摄像头 while not app.need_exit(): # 一直循环，直到程序退出（可以通过按下设备的功能按键退出或者 MaixVision 点击停止按钮退出） img cam.read() # 读取摄像头画面保存到 img 变量，可以通过 print(img) 来打印 img 的详情 disp.show(img) # 将 img 显示到屏幕上 ``` * `yolov5.py` 会检测摄像头画面中的物体框出来并显示到屏幕上，支持 80 种物体的检测，具体请看[YOLOv5 物体检测](./vision/yolov5.html)。 其它例程可以自行尝试。 > 如果你使用相机例程遇到了图像显示卡顿，可能是网络不通畅，或者 USB 线质量或者主机 USB 质量太差造成，可以更换连接方式或者更换线缆、主机 USB 口或者电脑等。 ## 安装应用到设备 上面是在设备中运行代码，`MaixVision` 断开后代码就会停止运行，如果想让代码出现在开机菜单中，可以打包成应用安装到设备上。 点击 `MaixVision` 左下侧的安装应用按钮，填写应用信息，会将应用安装到设备上，然后在设备上就能看到应用了。 也可以选择打包应用，将你的应用分享到[MaixHub 应用商店](https://maixhub.com/app)。 > 默认例程没有显式编写退出功能，进入应用后按下设备的功能按键即可退出应用。（对于 MaixCAM 是 user 键） 如果想让程序开机自启动，可以在 `设置 > 开机启动` 中设置。 ## 下一步 看到这里，如果你觉得不错，**请务必来 [github](https://github.com/sipeed/MaixPy) 给 MaixPy 开源项目点一个 star（需要先登录 github）, 你的 star 和认同是我们不断维护和添加新功能的动力！** 到这里你已经体验了一遍使用和开发流程了，接下来可以学习 `MaixPy` 语法和功能相关的内容，请按照左边的目录进行学习，如果遇到 `API` 使用问题，可以在[API 文档](/api/)中查找。 学习前最好带着自己学习的目的学，比如做一个有趣的小项目，这样学习效果会更好，项目和经验都可以分享到[MaixHub 分享广场](https://maixhub.com/share)，会获得现金奖励哦！ ## 分享交流 * **[MaixHub 项目和经验分享](https://maixhub.com/share)** ：分享你的项目和经验，获得现金打赏，获得官方打赏的基本要求： * **可复现型**：较为完整的项目制作复现过程。 * **炫耀型**：无详细的项目复现过程，但是项目展示效果吸引人。 * Bug 解决经验型：解决了某个难题的过程和具体解决方法分享。 * [MaixPy 官方论坛](https://maixhub.com/discussion/maixpy)（提问和交流） * QQ 群： （建议在 QQ 群提问前先发个帖，方便群友快速了解你需要了什么问题，复现过程是怎样的） * MaixPy (v4) AI 视觉交流大群: 862340358 * Telegram: [MaixPy](https://t.me/maixpy) * MaixPy 源码问题: [MaixPy issue](https://github.com/sipeed/MaixPy/issues) * 商业合作或批量购买请联系 support@sipeed.com 。"},"/maixpy/doc/zh/video/jpeg_streaming.html":{"title":"MaixPy 视频流 JPEG 推流 / 发送图片到服务器","content":" title: MaixPy 视频流 JPEG 推流 / 发送图片到服务器 update: date: 2024 04 03 author: neucrack version: 1.0.0 content: 初版文档 ## 简介 有时需要将图像发送到服务器，或者将摄像头的视频推送到服务器，这里提供一个最简单的方法，即压缩成 `JPEG` 图片，然后一张一张地发送到服务器。 注意，这是一种最简单的方法，不算很正规的视频推流方法，也不适合高分辨率高帧率的视频流，因为这只是一张一张发送图片，如果要高效推送视频流，请使用后文的 `RTSP` 或者 `RTMP` 模块。 ## 使用方法 ```python from maix import image import requests # create image img image.Image(640, 480, image.Format.FMT_RGB) # draw something img.draw_rect(60, 60, 80, 80, image.Color.from_rgb(255, 0, 0)) # convert to jpeg jpeg img.to_format(image.Format.FMT_JPEG) # image.Format.FMT_PNG # get jpeg bytes jpeg_bytes jpeg.to_bytes() # faster way, borrow memory from jpeg object, # but be carefully, when jpeg object is deleted, jpeg_bytes object MUST NOT be used, or program will crash # jpeg_bytes jpeg.to_bytes(copy False) # send image binary bytes to server url \"http://192.168.0.123:8080/upload\" res requests.post(url, data jpeg_bytes) print(res.status_code) print(res.text) ``` 可以看到，先将图片转换成了 `JPEG` 格式，然后将 `JPEG` 图片的二进制数据通过`TCP`发送到服务器。"},"/maixpy/doc/zh/source_code/faq.html":{"title":"MaixPy 源代码常见问题","content":"MaixPy 源代码常见问题 ## subprocess.CalledProcessError: Command '('lsb_release', ' a')' returned non zero exit status 1. 以 root 身份编辑 `/usr/bin/lsb_release`，将第一行从 `#!/usr/bin/python3` 更改为 `python3`。 然后重新编译,应该就可以工作了。 ## ImportError: arg(): could not convert default argument 'format: maix::image::Format' in method '<class 'maix._maix.camera.Camera'>.**init**' into a Python object (type not registered yet?) Pybind11 需要你先注册 `image::Format`，然后才能在 `camera::Camera` 中使用它,所以我们必须先在生成的 `build/maixpy_wrapper.cpp` 源文件中定义 `image::Format`。 要实现这一点,请编辑 `components/maix/headers_priority.txt`,被依赖的应该放在依赖它的前面。 例如: ``` maix_image.hpp maix_camera.hpp ```"},"/maixpy/doc/zh/source_code/build.html":{"title":"MaixPy 开发源代码指南","content":" title: MaixPy 开发源代码指南 ## 获取源代码 ```shell git clone https://github.com/sipeed/MaixPy cd MaixPy ``` ## 构建并打包成 wheel 文件 ```shell python setup.py bdist_wheel maixcam ``` `maixcam` 可以被替换为其他板卡配置, 请查看 [setup.py]([./configs](https://github.com/sipeed/MaixPy/blob/main/setup.py)) 中的 `platform_names` 变量。 构建成功后, 你会在 `dist` 目录中找到 wheel 文件, 使用 `pip install U MaixPy****.wheel` 在你的设备上安装或升级。 > `python setup.py bdist_wheel maixcam skip build` 不会执行构建命令, 只会打包 wheel 文件, 因此你可以先使用 `maixcdk menuconfig` 和 `maixcdk build` 来自定义构建。 ## 手动构建 ```shell maixcdk build ``` ## 修改源代码后运行测试 * 首先, 构建源代码 ```shell maixcdk build ``` * 如果为 PC 自身构建(平台 `linux`): 然后执行 `./run.sh your_test_file_name.py` 来运行 Python 脚本。 ```shell cd test ./run.sh examples/hello_maix.py ``` * 如果为板卡交叉编译: * 最快的方式是将 `maix` 目录复制到设备的 `/usr/lib/python3.11/site packages/` 目录, 然后在设备上运行脚本。 * 或者打包 wheel 文件并在设备上使用 `pip install U MaixPy****.wheel` 安装, 然后在设备上运行脚本。 ## 本地预览文档 文档位于 [docs](https://github.com/sipeed/MaixPy/tree/main/docs) 目录, 使用 `Markdown` 格式, 你可以使用 [teedoc](https://github.com/teedoc/teedoc) 来生成网页版本的文档。 API 文档会在构建 MaixPy 固件时生成, **如果你没有构建 MaixPy, API 文档将会是空的**。 ```shell pip install teedoc U cd docs teedoc install i https://pypi.tuna.tsinghua.edu.cn/simple teedoc serve ``` 然后访问 `http://127.0.0.1:2333` 在网页浏览器中预览文档。 ## 对于想要贡献的开发者 请查看 [MaixPy 开发源代码指南](./contribute.html) 如果在使用源代码时遇到任何问题, 请先参考 [FAQ](./faq.html)。"},"/maixpy/doc/zh/source_code/maixcdk.html":{"title":"切换到 MaixCDK 使用 C/C++ 开发应用","content":" title: 切换到 MaixCDK 使用 C/C++ 开发应用 除了使用 MaixPy 开发，还有对应的 C/C++ SDK 可以使用，项目名称为 [MaixCDK](https://github.com/sipeed/MaixCDK)。 ## MaixCDK 介绍 MaixPy 基于 MaixCDK 构建，MaixPy 的大多数 API 都是基于 MaixCDK 的 API 自动生成的，所以 MaixPy 有的功能 MaixCDK 都包含。 如果你更熟悉 C/C++ 编程，或者需要更高的性能，可以使用 MaixCDK 进行开发。 ## MaixCDK 使用 MaixCDK 代码仓库地址：[github.com/sipeed/MaixCDK](https://github.com/sipeed/MaixCDK), 你可以在这里找到 MaixCDK 的代码和文档。"},"/maixpy/doc/zh/peripheral/gpio.html":{"title":"","content":""},"/maixpy/doc/zh/peripheral/uart.html":{"title":"","content":""},"/maixpy/doc/zh/peripheral/pwm.html":{"title":"","content":""},"/maixpy/doc/zh/vision/yolov5.html":{"title":"MaixPy 使用 YOLOv5 模型进行目标检测","content":" title: MaixPy 使用 YOLOv5 模型进行目标检测 ## 目标检测概念 目标检测是指在图像或视频中检测出目标的位置和类别，比如在一张图中检测出苹果、飞机等物体，并且标出物体的位置。 和分类不同的是多了一个位置信息，所以目标检测的结果一般是一个矩形框，框出物体的位置。 ## MaixPy 中使用目标检测 MaixPy 默认提供了 `YOLOv5` 模型，可以直接使用： ```python from maix import camera, display, image, nn, app detector nn.YOLOv5(model \"/root/models/yolov5s.mud\") cam camera.Camera(detector.input_width(), detector.input_height(), detector.input_format()) dis display.Display() while not app.need_exit(): img cam.read() objs detector.detect(img, conf_th 0.5, iou_th 0.45) for obj in objs: img.draw_rect(obj.x, obj.y, obj.w, obj.h, color image.COLOR_RED) msg f'{detector.labels[obj.class_id]}: {obj.score:.2f}' img.draw_string(obj.x, obj.y, msg, color image.COLOR_RED) dis.show(img) ``` 效果视频: <video playsinline controls autoplay loop muted preload src \"https://wiki.sipeed.com/maixpy/static/video/detector.mp4\" type \"video/mp4\"> 这里使用了摄像头拍摄图像，然后传给 `detector`进行检测，得出结果后，将结果(分类名称和位置)显示在屏幕上。 更多 API 使用参考 [maix.nn](/api/maix/nn.html) 模块的文档。 ## 训练自己的目标检测模型 请到[MaixHub](https://maixhub.com) 学习并训练目标检测模型，创建项目时选择`目标检测模型`即可。"},"/maixpy/doc/zh/source_code/add_c_module.html":{"title":"给 MaixPy 添加一个 C/C++ 模块","content":" title: 给 MaixPy 添加一个 C/C++ 模块 ## 简介 有时候需要高效地执行某个函数， Python 的速度无法满足时，就可以使用 C/C++ 或者其它编译型语言来实现。 ## 通用函数封装 如果你想封装的函数实现的功能不依赖 MaixPy 的其它功能，直接使用 Python 使用 C/C++ 添加模块的通用方法，具体方法可以自行百度，比如 ffi， ctype 等 > 欢迎 PR 添加方法 ## 如果你的模块还想依赖 MaixPy 的其它基础 API 你需要先学会编译使用 [MaixCDK](https://github.com/sipeed/MaixCDK)， 因为 MaixPy 就是从 MaixCDK 生成的 API， MaixPy 里面有的功能 MaixCDK 里面也有， 然后 。。。TODO"},"/maixpy/doc/zh/source_code/contribute.html":{"title":"参与 MaixPy 文档修改和贡献代码","content":" title: 参与 MaixPy 文档修改和贡献代码 ## 参与 MaixPy 文档修改 * 点击要修改的文档右上角的`编辑本页`按钮，进入 github 源文档页面。 * 保证已经登录了 GitHub 账号。 * 在 github 预案文档页面点击右上角铅笔按钮修改文档内容。 * github 会提示需要 fork 一份到自己的仓库，点击 fork 按钮。 > 这一步就是将 MaixPy 源码仓库复刻一份到你自己的账号下，这样你就可以自由修改了。 * 修改文档内容，然后在页面底部填写修改说明，点击提交修改。 * 然后在你的仓库中找到 Pull requests 按钮，点击创建一个 Pull requests。 * 然后在弹出的页面中填写修改说明，点击提交 Pull requests，其它人和管理员就可以在[Pull requests 页面](https://github.com/sipeed/MaixPy/pulls)看到你的修改了。 * 等待管理员审核通过后，你的修改就会合并到 MaixPy 源码仓库中了。 * 合并成功后，文档会自动更新到 [MaixPy 官方文档](https://wiki.sipeed.com/maixpy)。 > 文档经过 CDN 缓存了的，可能需要等待一段时间才能看到更新，紧急更新可以联系管理员手动刷新。 > 也可以访问 [en.wiki.sipeed.com/maixpy](https://en.wiki.sipeed.com/maixpy) 查看 github pages 服务版本，这个是没有缓存实时更新的。 ## 参与 MaixPy 代码贡献 * 访问 MaixPy 代码仓库地址：[github.com/sipeed/MaixPy](https://github.com/sipeed/MaixPy) * 在修改代码前最好先创建一个 [issue](https://github.com/sipeed/MaixPy/issues) ，描述你要修改的内容让大家知道你的想法和计划，这样大家可以参与修改讨论，以免重复劳动。 * 点击右上角的 fork 按钮，将 MaixPy 代码仓库复刻一份到你自己的账号下。 * 然后在你的账号下 clone 一份代码到本地。 * 修改代码后提交到你的仓库中。 * 然后在你的仓库中找到 Pull requests 按钮，点击创建一个 Pull requests。 * 然后在弹出的页面中填写修改说明，点击提交 Pull requests，其它人和管理员就可以在[Pull requests 页面](https://github.com/sipeed/MaixPy/pulls)看到你的修改了。 * 等待管理员审核通过后，你的修改就会合并到 MaixPy 源码仓库中了。 > 需要注意的是 MaixPy 的代码大多数是从 [MaixCDK](https://github.com/sipeed/MaixCDK) 自动生成的，所以如果你修改 C/C++ 源码，很有可能你需要先修改这个仓库。"},"/maixpy/doc/zh/peripheral/wdt.html":{"title":"","content":""},"/maixpy/doc/zh/peripheral/spi.html":{"title":"","content":""},"/maixpy/doc/zh/peripheral/i2c.html":{"title":"","content":""},"/maixpy/doc/zh/vision/apriltag.html":{"title":"MaixPy 识别Apriltag标签","content":" title: MaixPy 识别Apriltag标签 update: date: 2024 04 03 author: lxowalle version: 1.0.0 content: 初版文档 阅读本文前，确保已经知晓如何开发MaixPy，详情请阅读[MaixVision MaixPy 编程 + 图形化积木编程](../basic/maixvision.html) ## 简介 本文介绍如何使用MaixPy来识别Apriltag标签 ## 使用 MaixPy 识别Apriltag标签 MaixPy的 `maix.image.Image`中提供了`find_apriltags`方法，可以可以识别apriltag标签。 ### 如何识别Apriltag标签 一个简单的示例，实现识别apriltag标签并画框 ```python from maix import image, camera, display cam camera.Camera() disp display.Display() families image.ApriltagFamilies.TAG36H11 x_scale cam.width() / 160 y_scale cam.height() / 120 while 1: img cam.read() new_img img.resize(160, 120) apriltags new_img.find_apriltags(families families) for a in apriltags: corners a.corners() for i in range(4): corners[i][0] int(corners[i][0] * x_scale) corners[i][1] int(corners[i][1] * y_scale) x int(a.x() * x_scale) y int(a.y() * y_scale) w int(a.w() * x_scale) h int(a.h() * y_scale) for i in range(4): img.draw_line(corners[i][0], corners[i][1], corners[(i + 1) % 4][0], corners[(i + 1) % 4][1], image.COLOR_RED) img.draw_string(x + w, y, \"id: \" + str(a.id()), image.COLOR_RED) img.draw_string(x + w, y + 15, \"family: \" + str(a.family()), image.COLOR_RED) disp.show(img) ``` 步骤： 1. 导入image、camera、display模块 ```python from maix import image, camera, display ``` 2. 初始化摄像头和显示 ```python cam camera.Camera() disp display.Display() ``` 3. 从摄像头获取图片并显示 ```python while 1: img cam.read() disp.show(img) ``` 4. 调用`find_apriltags`方法识别摄像头图片中的apriltag标签 ```python new_img img.resize(160, 120) apriltags new_img.find_apriltags(families families) ``` `img`是通过`cam.read()`读取到的摄像头图像 `img.resize(160, 120)`是用来将图像缩放得更小，用更小的图像来让算法计算得更快 `new_img.find_apriltags(families families)`用来寻找apriltag标签，并将查询结果保存到`apriltags`，以供后续处理。其中families用来选择apriltag族，默认为`image.ApriltagFamilies.TAG36H11` 5. 处理识别标签的结果并显示到屏幕上 ```python for a in apriltags: # 获取位置信息（并映射坐标到原图） x int(a.x() * x_scale) y int(a.y() * y_scale) w int(a.w() * x_scale) corners a.corners() for i in range(4): corners[i][0] int(corners[i][0] * x_scale) corners[i][1] int(corners[i][1] * y_scale) # 显示 for i in range(4): img.draw_line(corners[i][0], corners[i][1], corners[(i + 1) % 4][0], corners[(i + 1) % 4][1], image.COLOR_RED) img.draw_string(x + w, y, \"id: \" + str(a.id()), image.COLOR_RED) img.draw_string(x + w, y + 15, \"family: \" + str(a.family()), image.COLOR_RED) img.draw_string(x + w, y + 30, \"rotation : \" + str(180 * a.rotation() // 3.1415), image.COLOR_RED) ``` 遍历`apriltags`的成员，`apriltags`是通过`img.find_apriltags()`扫描apriltag标签的结果，如果找不到标签则`apriltags`的成员为空 `x_scale`和`y_scale`用来映射坐标，由于`new_img`是缩放后的图像，计算apriltag的坐标时需要经过映射后才能正常的画在原图`img`上 `a.corners()`用来获取已扫描到的标签的四个顶点坐标，`img.draw_line()`利用这四个顶点坐标画出标签的形状 `img.draw_string`用来显示标签的内容，其中`a.x()`和`a.y()`用来获取标签左上角坐标x和坐标y，`a.id()`用来获取标签的id，`a.family()`用来获取标签族类型，`a.rotation()`用来获取标签的旋转角度。 ### 常用参数说明 列举常用参数说明，如果没有找到可以实现应用的参数，则需要考虑是否使用其他算法实现，或者基于目前算法的结果扩展所需的功能 参数 说明 示例 roi 设置算法计算的矩形区域，roi [x, y, w, h]，x，y表示矩形区域左上角坐标，w，h表示矩形区域的宽度和高度，默认为整张图片 计算坐标为(50,50)，宽和高为100的区域<br />```img.find_apriltags(roi [50, 50, 100, 100])``` families apriltag标签家族类型 扫描TAG36H11家族的标签<br />```img.find_apriltags(families image.ApriltagFamilies.TAG36H11)``` 本文介绍常用方法，更多 API 请看 API 文档的 [image](../../../api/maix/image.html) 部分。"},"/maixpy/doc/zh/vision/custmize_model.html":{"title":"MaixPy 自定义（离线训练） AI 模型和运行","content":" title: MaixPy 自定义（离线训练） AI 模型和运行 update: date: 2024 4 23 version: v1.0 author: dragonforward content: 加入了YOLOv5s部署 > 本文来自社区用户 dragonforward 的贡献 > 本博客将向你展示零基础一步步的部署好自己的yolov5s模型（博主展示的是安全帽模型），训练就引用我自己之前写过的，已经训练好的可以跳过该部分，其中有部分不一样。 ## 获得自定义训练得到的yolov5s onnx模型 ### 准备自定义数据集（博主用的是VOC数据集） `数据集目录结构`如下： ``` └─VOC2028:\t\t自定义数据集 ├─Annotations\t存放的是数据集标签文件，xml格式 ├─ImageSets\t\t数据集的划分文件 │ └─Main ├─JPEGImages\t存放的是数据集图片 ``` `分割数据集` 在split_train_val.py文件路径下执行`python3 split_train_val.py`会得到一下目录结构： ``` └─VOC2028:\t\t自定义数据集 ├─Annotations\t存放的是数据集标签文件，xml格式 ├─ImageSets\t\t数据集的划分文件 │ └─Main test.txt └─test.txt └─train.txt └─val.txt ├─JPEGImages\t存放的是数据集图片 ├─split_train_val.py\t分割数据集的py文件 ``` `split_train_val.py文件代码如下`： ``` # * coding: utf 8 * \"\"\" Author:dragonforward 简介：分训练集、验证集和测试集，按照 8：1：1 的比例来分，训练集8，验证集1，测试集1 \"\"\" import os import random import argparse parser argparse.ArgumentParser() # xml文件的地址，根据自己的数据进行修改 xml一般存放在Annotations下 parser.add_argument(' xml_path', default 'Annotations/', type str, help 'input xml label path') # 数据集的划分，地址选择自己数据下的ImageSets/Main parser.add_argument(' txt_path', default 'ImageSets/Main/', type str, help 'output txt label path') opt parser.parse_args() train_percent 0.8 # 训练集所占比例 val_percent 0.1 # 验证集所占比例 test_persent 0.1 # 测试集所占比例 xmlfilepath opt.xml_path txtsavepath opt.txt_path total_xml os.listdir(xmlfilepath) if not os.path.exists(txtsavepath): os.makedirs(txtsavepath) num len(total_xml) list list(range(num)) t_train int(num * train_percent) t_val int(num * val_percent) train random.sample(list, t_train) num1 len(train) for i in range(num1): list.remove(train[i]) val_test [i for i in list if not i in train] val random.sample(val_test, t_val) num2 len(val) for i in range(num2): list.remove(val[i]) file_train open(txtsavepath + '/train.txt', 'w') file_val open(txtsavepath + '/val.txt', 'w') file_test open(txtsavepath + '/test.txt', 'w') for i in train: name total_xml[i][: 4] + '\\n' file_train.write(name) for i in val: name total_xml[i][: 4] + '\\n' file_val.write(name) for i in list: name total_xml[i][: 4] + '\\n' file_test.write(name) file_train.close() file_val.close() file_test.close() ``` `voc转label得到label文件` 目录结构如下： ``` └─VOC2028:\t\t自定义数据集 ├─Annotations\t存放的是数据集标签文件，xml格式 ├─ImageSets\t\t数据集的划分文件 │ └─Main ├─JPEGImages\t存放的是数据集图片 └─labels\t\tyolov5将此文件夹当作训练的标注文件夹 └─voc_label.py ``` `voc_label.py文件代码如下`： ``` # * coding: utf 8 * import xml.etree.ElementTree as ET import os sets ['train', 'val', 'test'] # 如果你的Main文件夹没有test.txt，就删掉'test' classes [\"hat\", \"people\"] # 改成自己的类别，VOC数据集有以下20类别 # classes [\"brickwork\", \"coil\",\"rebar\"] # 改成自己的类别，VOC数据集有以下20类别 # classes [\"aeroplane\", 'bicycle', 'bird', 'boat', 'bottle', 'bus', 'car', 'cat', 'chair', 'cow', 'diningtable', 'dog', # 'horse', 'motorbike', 'person', 'pottedplant', 'sheep', 'sofa', 'train', 'tvmonitor'] # class names # abs_path os.getcwd() /root/yolov5/data/voc_label.py abs_path '/root/yolov5/data/' def convert(size, box): dw 1. / (size[0]) dh 1. / (size[1]) x (box[0] + box[1]) / 2.0 1 y (box[2] + box[3]) / 2.0 1 w box[1] box[0] h box[3] box[2] x x * dw w w * dw y y * dh h h * dh return x, y, w, h def convert_annotation(image_id): in_file open(abs_path + '/VOC2028/Annotations/%s.xml' % (image_id), encoding 'UTF 8') out_file open(abs_path + '/VOC2028/labels/%s.txt' % (image_id), 'w') tree ET.parse(in_file) root tree.getroot() size root.find('size') w int(size.find('width').text) h int(size.find('height').text) for obj in root.iter('object'): difficult obj.find('difficult').text # difficult obj.find('Difficult').text cls obj.find('name').text if cls not in classes or int(difficult) 1: continue cls_id classes.index(cls) xmlbox obj.find('bndbox') b (float(xmlbox.find('xmin').text), float(xmlbox.find('xmax').text), float(xmlbox.find('ymin').text), float(xmlbox.find('ymax').text)) b1, b2, b3, b4 b # 标注越界修正 if b2 > w: b2 w if b4 > h: b4 h b (b1, b2, b3, b4) bb convert((w, h), b) out_file.write(str(cls_id) + \" \" + \" \".join([str(a) for a in bb]) + '\\n') for image_set in sets: if not os.path.exists(abs_path + '/VOC2028/labels/'): os.makedirs(abs_path + '/VOC2028/labels/') image_ids open(abs_path + '/VOC2028/ImageSets/Main/%s.txt' % (image_set)).read().strip().split() list_file open(abs_path + '/VOC2028/%s.txt' % (image_set), 'w') for image_id in image_ids: list_file.write(abs_path + '/VOC2028/JPEGImages/%s.jpg\\n' % (image_id)) # 要么自己补全路径，只写一半可能会报错 convert_annotation(image_id) list_file.close() ``` ![picture 0](./assets/custmize_model8.png) ### 训练模型 配置环境 ``` git clone https://github.com/ultralytics/yolov5 cd yolov5 pip install r requirements.txt pip install onnx ``` 下载预训练权重（博主尝试了v7.0的和v6.0的pt都可以） ``` https://github.com/ultralytics/yolov5/releases/download/v7.0/yolov5s.pt ``` ![picture 1](./assets/custmize_model11.png) 训练（博主使用的是学校的集群进行训练） ``` python3 train.py weights weights/yolov5s.pt cfg models/yolov5s.yaml data data/safthat.yaml epochs 150 batch size 16 multi scale device 0 ``` ![picture 2](./assets/custmize_model9.png) ``` python3 detect.py source /root/yolov5/data/images/000000.jpg weights /root/yolov5/runs/train/exp13/weights/best.pt conf thres 0.25 ``` ![picture 3](./assets/custmize_model10.png) 导出onnx模型，由于学校服务器目前去教学上课去了，他们上完课才能分配我就用电脑本机的conda环境导出 下面为啥使用` imgsz 224 320`,原因就是比较适配屏幕，加上我尝试640*640的，摄像头报错，提示是640*480这样，然后我就看到sipeed那个yolov5s是320*224的，我也就和他保持一致吧 ``` python export.py weights yolov5s_hat.pt include onnx opset 16 imgsz 224 320 ``` ![picture 4](./assets/custmize_model5.png) 模型查看通过网址输入netron.app查看三个输出： ![picture 5](./assets/custmize_model2.png) 下面是博主的三个输出 ``` onnx::Shape_329 onnx::Shape_384 onnx::Shape_439 ``` ## 模型转化（关键） ### 安装docker环境（已安装过的可以跳过） ``` 安装docker依赖的基础软件 sudo apt get update sudo apt get install apt transport https ca certificates curl gnupg agent software properties common 添加官方来源 curl fsSL https://download.docker.com/linux/ubuntu/gpg sudo apt key add sudo add apt repository \"deb [arch amd64] https://download.docker.com/linux/ubuntu $(lsb_release cs) stable\" 安装 docker sudo apt get update sudo apt get install docker ce docker ce cli containerd.io ``` ### 开始量化模型实操（！！！） ### 准备工作 ``` https://github.com/sophgo/tpu mlir/releases/tag/v1.7 上面网址下载 tpu mlir resource.tar 和 tpu_mlir 1.7 py3 none any.whl ``` ![picture 6](./assets/custmize_model3.png) 为什么拉取最新版，因为我用3.1版本失败了，工具在一直更新，最好保持最新，可以看下面图片我使用3.1版本也试过 ![picture 7](./assets/custmize_model7.png) ``` docker pull sophgo/tpuc_dev:latest 进入容器后将上面的准备的两个文件拷贝到workspace目录 root@3d517bc7f51f:/workspace/model_yolov5s# cd .. root@3d517bc7f51f:/workspace# ls model_yolov5s tpu mlir resource tpu mlir resource.tar tpu_mlir 1.7 py3 none any.whl root@3d517bc7f51f:/workspace# 下面两个二选一，我建议是第二个，离线安装 pip install tpu_mlir[all]或者pip install tpu_mlir * py3 none any.whl[all] 博主是选的第二个 pip install tpu_mlir 1.7 py3 none any.whl 以及安装它的全部依赖 pip install tpu_mlir 1.7 py3 none any.whl[all] 解压 tar xvf tpu mlir resource.tar 修改文件夹名字 mv regression/ tpu mlir resource/ mkdir model_yolov5s && cd model_yolov5s cp rf ../tpu_mlir_resource/dataset/COCO2017 . cp rf ../tpu_mlir_resource/image . 把之前准备好的图片100张一集一张测试图片和onnx模型传递到如下 root@3d517bc7f51f:/workspace# cd model_yolov5s/ root@3d517bc7f51f:/workspace/model_yolov5s# ls COCO2017 image workspace yolov5n_hat.onnx yolov5s_hat.onnx root@3d517bc7f51f:/workspace/model_yolov5s# cd COCO2017/ root@3d517bc7f51f:/workspace/model_yolov5s/COCO2017# ls 000000.jpg 000011.jpg 000022.jpg 000032.jpg 000042.jpg 000053.jpg 000066.jpg 000076.jpg 000086.jpg 000096.jpg 000002.jpg 000012.jpg 000023.jpg 000033.jpg 000043.jpg 000054.jpg 000067.jpg 000077.jpg 000087.jpg 000101.jpg 000003.jpg 000013.jpg 000024.jpg 000034.jpg 000044.jpg 000055.jpg 000068.jpg 000078.jpg 000088.jpg 000102.jpg 000004.jpg 000014.jpg 000025.jpg 000035.jpg 000045.jpg 000058.jpg 000069.jpg 000079.jpg 000089.jpg 000103.jpg 000005.jpg 000015.jpg 000026.jpg 000036.jpg 000046.jpg 000059.jpg 000070.jpg 000080.jpg 000090.jpg 000104.jpg 000006.jpg 000016.jpg 000027.jpg 000037.jpg 000048.jpg 000061.jpg 000071.jpg 000081.jpg 000091.jpg 000105.jpg 000007.jpg 000017.jpg 000028.jpg 000038.jpg 000049.jpg 000062.jpg 000072.jpg 000082.jpg 000092.jpg 000106.jpg 000008.jpg 000019.jpg 000029.jpg 000039.jpg 000050.jpg 000063.jpg 000073.jpg 000083.jpg 000093.jpg 000107.jpg 000009.jpg 000020.jpg 000030.jpg 000040.jpg 000051.jpg 000064.jpg 000074.jpg 000084.jpg 000094.jpg 000108.jpg 000010.jpg 000021.jpg 000031.jpg 000041.jpg 000052.jpg 000065.jpg 000075.jpg 000085.jpg 000095.jpg 000109.jpg root@3d517bc7f51f:/workspace/model_yolov5s/COCO2017# ls l grep \"^ \" wc l 100 root@3d517bc7f51f:/workspace/model_yolov5s/COCO2017# ls l grep \"^ \" wc l可以查看一下图片多少个，COCO2017文件下的图片博主替换了安全帽的100张图片以及测试图片同样 回到 model_yolov5s root@3d517bc7f51f:/workspace/model_yolov5s/COCO2017# cd .. root@3d517bc7f51f:/workspace/model_yolov5s# ls COCO2017 image workspace yolov5n_hat.onnx yolov5s_hat.onnx root@3d517bc7f51f:/workspace/model_yolov5s# 接着 mkdir workspace && cd workspace 执行下面命令ONNX 转 MLIR（记得output_names换为自己的） model_transform \\ model_name yolov5s \\ model_def ../yolov5s_hat.onnx \\ input_shapes [[1,3,224,320]] \\ mean 0.0,0.0,0.0 \\ scale 0.0039216,0.0039216,0.0039216 \\ keep_aspect_ratio \\ pixel_format rgb \\ output_names onnx::Shape_329,onnx::Shape_439,onnx::Shape_384 \\ test_input ../image/hat.jpg \\ test_result yolov5s_top_outputs.npz \\ mlir yolov5s.mlir 执行下面命令MLIR 转 INT8 模型，转 INT8 模型前需要跑 calibration, 得到校准表 run_calibration yolov5s.mlir \\ dataset ../COCO2017 \\ input_num 100 \\ o yolov5s_cali_table 接着执行下面 model_deploy \\ mlir yolov5s.mlir \\ quantize INT8 \\ calibration_table yolov5s_cali_table \\ processor cv181x \\ test_input yolov5s_in_f32.npz \\ test_reference yolov5s_top_outputs.npz \\ tolerance 0.85,0.45 \\ model yolov5s_cv181x_int8_sym.cvimodel 最后你会得到如下： root@3d517bc7f51f:/workspace/model_yolov5s/workspace# ls _weight_map.csv yolov5s_cv181x_int8_sym.cvimodel yolov5s_origin.mlir build_flag.json yolov5s_cv181x_int8_sym_final.mlir yolov5s_top_f32_all_origin_weight.npz final_opt.onnx yolov5s_cv181x_int8_sym_tensor_info.txt yolov5s_top_f32_all_weight.npz yolov5s.mlir yolov5s_cv181x_int8_sym_tpu.mlir yolov5s_top_outputs.npz yolov5s_cali_table yolov5s_in_f32.npz yolov5s_tpu_addressed_cv181x_int8_sym_weight.npz yolov5s_cv181x_int8_sym yolov5s_opt.onnx.prototxt yolov5s_tpu_addressed_cv181x_int8_sym_weight_fix.npz root@3d517bc7f51f:/workspace/model_yolov5s/workspace# ``` 通过上述步骤，你就可以得到量化后的可以部署到开发板上的模型的 解答： 上面为什么会是cv181x，因为我自己先用了一个实验了一下，然后报错如下： ``` [I] load cvimodel from: /root/models/yolov5n.cvimodel cvimodel built for cv180x CANNOT run on platform cv181x failed to parse cvimodel ``` ### 实机运行 `yolov5s_hat.mud内容如下`如下： ``` [basic] type cvimodel model yolov5s_hat_cv181x_int8_sym.cvimodel [extra] model_type yolov5 input_type rgb mean 0, 0, 0 scale 0.00392156862745098, 0.00392156862745098, 0.00392156862745098 anchors 10,13, 16,30, 33,23, 30,61, 62,45, 59,119, 116,90, 156,198, 373,326 labels hat,person ``` 运行代码 ``` from maix import camera, display, image, nn, app detector nn.YOLOv5(model \"/root/models/yolov5s_hat.mud\") cam camera.Camera(detector.input_width(), detector.input_height(), detector.input_format()) dis display.Display() print(\"www\") print(detector.input_width(),detector.input_height(), detector.input_format()) while not app.need_exit(): img cam.read() objs detector.detect(img, conf_th 0.5, iou_th 0.45) for obj in objs: img.draw_rect(obj.x, obj.y, obj.w, obj.h, color image.COLOR_RED) msg f'{detector.labels[obj.class_id]}: {obj.score:.2f}' img.draw_string(obj.x, obj.y, msg, color image.COLOR_RED) dis.show(img) ``` ![picture 8](./assets/custmize_model4.png) 其中10.84.117.1就是ip地址，将cvmodel和mud上传到`/root/models/` 路径下 ![picture 9](./assets/custmize_model1.png) 打包完成后安装应用然后运行就行，也可以ide运行 ![picture 10](./assets/custmize_model6.png) 视频链接： ``` https://www.bilibili.com/video/BV1xz421S7Rx/?spm_id_from 333.999.0.0&vd_source b1fff0f773136d7d05331087929c7739 ``` ## 感谢 感谢`谁说现在是冬天呢 `一些思路"},"/maixpy/doc/zh/vision/self_learn_classifier.html":{"title":"MaixPy 自学习分类器","content":" title: MaixPy 自学习分类器 ## MaixPy 自学习分类器介绍 一般情况下我们要识别新的类别，需要在电脑端重新采集数据集并训练，步骤很麻烦，难度较高，这里提供一种不需要电脑端训练，而是直接在设备端就能秒学习新的物体，适合场景不太复杂的使用场景。 比如眼前有饮料瓶和手机，使用设备分别拍一张它们的照片作为两个分类的依据，然后再采集几张他们各个角度的照片，提取它们的特征保存，然后识别时根据图像的特征值分别和保存的特征值进行对比，和保存的哪个更相近就认为是对应的分类。 ## MaixPy 中使用自学习分类器 步骤： * 采集 n 张分类图。 * 采集 n*m 张图，每个分类采集 m 张，顺序无所谓。 * 启动学习。 * 识别图像输出结果。 简洁版本代码，完整版本请看例程里面的完整代码。 ```python from maix import nn, image classifier nn.SelfLearnClassifier(model \"/root/models/mobilenetv2.mud\", feature_layer None) img1 image.load(\"/root/1.jpg\") img2 image.load(\"/root/2.jpg\") img3 image.load(\"/root/3.jpg\") sample_1 image.load(\"/root/sample_1.jpg\") sample_2 image.load(\"/root/sample_2.jpg\") sample_3 image.load(\"/root/sample_3.jpg\") sample_4 image.load(\"/root/sample_4.jpg\") sample_5 image.load(\"/root/sample_5.jpg\") sample_6 image.load(\"/root/sample_6.jpg\") classifier.add_class(img1) classifier.add_class(img2) classifier.add_class(img3) classifier.add_sample(sample_1) classifier.add_sample(sample_2) classifier.add_sample(sample_3) classifier.add_sample(sample_4) classifier.add_sample(sample_5) classifier.add_sample(sample_6) classifier.learn() img image.load(\"/root/test.jpg\") max_idx, max_score classifier.classify(img) print(maix_idx, max_score) ```"},"/maixpy/doc/zh/vision/face_recognition.html":{"title":"MaixPy 人脸识别","content":" title: MaixPy 人脸识别 ## 人脸识别简介 人脸识别就是识别当前画面中的人脸的位置以及是谁。 所以人脸识别除了要检测到人脸，一般会有一个库来保存认识的人和不认识的人。 ## 识别原理 * 使用 AI 模型检测人脸，获得坐标和五官的坐标。 * 利用五官的坐标仿射变换将图中的脸拉正对其到标准脸的样子，方便模型提取脸的特征。 * 使用特征提取模型提取脸的特征值。 * 与库中记录的人脸特征值进行对比（计算保存的和当前画面中的脸的特征值的余弦距离，得出最小的距离的库中的人脸，小于设定的阈值就认为当前画面中就是这个库中的人） ## MaixPy 使用 MaixPy maix.nn 模块中提供了人脸识别的 API， 可以直接使用，模型也内置了，也可以到 [MaixHub 模型库](https://maixhub.com/model/zoo) 下载（筛选选则对应的硬件平台，比如 maixcam）。 识别： ```python from maix import nn recognizer nn.Face_Recognizer(model \"/root/models/face_recognizer.mud\") if os.path.exists(\"/root/faces.bin\"): recognizer.load_faces(\"/root/faces.bin\") cam camera.Camera(recognizer.input_width(), recognizer.input_height(), recognizer.input_format()) dis display.Display() while 1: img cam.read() faces recognizer.recognize(img) for obj in faces: img.draw_rect(obj.x, obj.y, obj.w, obj.h, color image.COLOR_RED) msg f'{recognizer.labels[obj.class_id]}: {obj.score:.2f}' img.draw_string(obj.x, obj.y, msg, color image.COLOR_RED) dis.show(img) ``` 第一次运行这个代码会发现能检测到人脸，但是都不认识，需要我们进入添加人脸模式学习人脸才行。 比如可以在用户按下按键的时候学习人脸： ```python faces recognizer.detect_faces(img) for face in faces: print(face) # 这里考虑到了一个画面中有多个人脸的情况 # 可以在这里根据 face 的坐标决定要不要添加到库里面 recognizer.add_face(face) recognizer.save_(faces)(\"/too/faces.bin\") ```"},"/maixpy/doc/zh/vision/object_track.html":{"title":"","content":""},"/maixpy/doc/zh/vision/display.html":{"title":"MaixPy 屏幕使用","content":" title: MaixPy 屏幕使用 update: date: 2024 03 31 author: neucrack version: 1.0.0 content: 初版文档 ## 简介 MaixPy 提供了`display`模块，可以将图像显示到屏幕上，同时，也可以将图像发送到 MaixVision 显示，方便调试和开发。 ## API 文档 本文介绍常用方法，更多 API 请看 API 文档的 [display](/api/maix/display.html) 部分。 ## 使用屏幕 * 导入`display`模块： ```python from maix import display ``` * 创建一个`Display`对象： ```python disp display.Display() ``` * 显示图像： ```python disp.show(img) ``` 这里`img`对象是`maix.image.Image`对象，可以通过`camera`模块的`read`方法获取，也可以通过`image`模块的`load`方法加载文件系统中的图像，也可以通过`image`模块的`Image`类创建一个空白图像。 比如： ```python from maix import image, display disp display.Display() img image.load(\"/root/dog.jpg\") disp.show(img) ``` 这里需要先把`dog.jpg`文件传到设备的`/root`目录下。 显示文字： ```python from maix import image, display disp display.Display() img image.Image(320, 240) img.draw_rectangle(0, 0, disp.width(), disp.height(), color image.Color.from_rgb(255, 0, 0), thickness 1) img.draw_rectangle(10, 10, 100, 100, color image.Color.from_rgb(255, 0, 0)) img.draw_string(10, 10, \"Hello MaixPy!\", color image.Color.from_rgb(255, 255, 255)) disp.show(img) ``` 从摄像头读取图像并显示： ```python from maix import camera, display, app disp display.Display() cam camera.Camera(320, 240) while not app.need_exit(): img cam.read() disp.show(img) ``` > 这里用了一个`while not app.need_exit():` 是方便程序在其它地方调用`app.set_exit_flag()`方法后退出循环。 ## 调整背光亮度 在系统的`设置`应用中可以手动调整背光亮度，如果你想在程序中调整背光亮度，可以使用`set_backlight`方法，参数就是亮度百分比，取值范围是 0 100： ```python disp.set_backlight(50) ``` 注意，程序退出回到应用选择界面后会自动恢复到系统设置的背光亮度。 ## 显示到 MaixVision 在使用 MaixVision 运行代码时，能够将图像显示到 MaixVision 上，方便调试和开发。 在调用`show`方法时，会自动压缩图像并发送到 MaixVision 显示。 当然，如果你没有屏幕，或者为了节省内存不想初始化屏幕，也可以直接调用`image.Image`对象的`send_to_maixvision`方法发送图像到 MaixVision 显示。 ```python from maix import image img image.Image(320, 240) img.draw_rectangle(0, 0, img.width(), img.height(), color image.Color.from_rgb(255, 0, 0), thickness 1) img.draw_rectangle(10, 10, 100, 100, color image.Color.from_rgb(255, 0, 0)) img.draw_string(10, 10, \"Hello MaixPy!\", color image.Color.from_rgb(255, 255, 255)) img.send_to_maixvision() ```"},"/maixpy/doc/zh/vision/body_key_points.html":{"title":"MaixPy 检测人体关键点姿态检测","content":" title: MaixPy 检测人体关键点姿态检测 ## 简介 使用 MaixPy 可以轻松检测人体关节的关键点的坐标，用在姿态检测比如坐姿检测，体感游戏输入等。 ## 使用 使用 MaixPy 的 maix.nn.BodyKeyPoints 类可以轻松实现： ```python from maix import nn, image, display detector nn.BodyKeyPoints(model \"/root/models/body_key_points.mud\") cam camera.Camera(recognizer.input_width(), recognizer.input_height(), recognizer.input_format()) dis display.Display() while 1: img cam.read() points detector.detect(img) for point in points: img.draw_circle(point[0], point[1], 3, color image.COLOR_RED, thickness 1) dis.show(img) ```"},"/maixpy/doc/zh/modules/thermal_cam.html":{"title":"","content":""},"/maixpy/doc/zh/modules/tof.html":{"title":"","content":""},"/maixpy/doc/zh/modules/acc.html":{"title":"","content":""},"/maixpy/doc/zh/audio/recognize.html":{"title":"","content":""}}